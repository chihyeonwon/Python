# 혼자 공부하는 파이썬 공부 노트

## 25년 다시 시작

# 자료형과 문자열 

## 표현식과 문장

파이썬에서는 어떠한 값을 만들어 내는 간단한 코드를 표현식이라고 부릅니다.
표현식이 하나 이상 모이면 문장이 되는데, 파이썬은 한 줄이 하나의 문장이 됩니다.

## 키워드

키워드는 특별한 의미가 부여된 단어로, 파이썬이 만들어질 때 이미 사용하겠다고 예약해 놓은 것입니다.
사용자가 키워드인지 아닌지를 구분해야 하는 이유는 프로그래밍 언어에서 사용자가 이름을 정할 때 키워드를 사용하면 안되기 때문입니다.

파이썬의 키워드를 확인해야 하는 경우 다음 코드로 확인할 수 있습니다.
```python
import keyword
print(keyword.kwlist)
```

## 식별자

식별자는 프로그래밍 언어에서 이름을 붙일 때 사용하는 단어입니다. 주로 변수 또는 함수 이름 등으로 사용됩니다.

식별자는 다음과 같은 규칙을 지켜 만들어야 합니다.

1. 키워드를 사용하면 안 됩니다.
2. 특수 문자는 언더 바만 허용됩니다.
3. 숫자로 시작하면 안 됩니다.
4. 공백을 포함할 수 없습니다.

## 스네이크 케이스와 캐멀 케이스

스네이크 케이스 : 단어 사이에 언더 바 기호를 붙여 식별자를 만듭니다. 
캐멀 케이스 : 단어들의 첫 글자를 대문자로 만들어 식별자를 만듭니다.

### 식별자를 구분하기

파이썬에서는 첫 번째 글자를 소문자로 적는다라는 캐멀 케이스는 사용하지 않습니다.
캐멀케이스로 작성되어 있으면 클래스이며, 스네이크 케이스로 작성되어 있으면 함수 또는 변수입니다.
그리고 뒤에 괄호가 붙어 있으면 함수이고, 괄호가 없으면 변수입니다.

## 주석

주석은 프로그램의 진행에 전혀 영향을 주지 않는 코드로, 프로그램을 설명하기 위해 사용합니다. # 이후의 글자는 주석 처리되어 프로그램에 어떠한 영향도 주지 않습니다.

## 연산자와 자료

연산자는 스스로 값이 되는 것은 아니고 값과 값 사이에 무언가 기능을 적용할 때 사용하는 것을 말합니다. 
자료는 리터럴이라고도 하는데, 숫자이든지 문자이든지 어떠한 값 자체를 의미합니다.

## 출력 print()

현재 무엇을 하는지 알 수 있또록 메시지를 출력하는 기본 방법입니다. print()함수는 다음과 같이 함수의 괄호 안에 출력하고 싶은 것을 나열해서 사용합니다.

## 줄바꿈하기

print 명령의 괄호 안에 아무것도 입력하지 않으면 단순하게 줄바꿈을 합니다.

output.py
```python
# 하나만 출력합니다.

print('# 하나만 출력합니다.')
print("Hello Python Progamming...!!")
print()

# 여러 개를 출력합니다.
print("# 여러 개를 출력합니다.")
print(10, 20, 30, 40, 50)
print("안녕하세요", "저의", "이름은",)
print()

# 아무것도 입력하지 않으면 단순하게 줄바꿈합니다.
print("# 아무것도 입력하지 않습니다.")
print("--- 확인 전용선 ---")
print()
print()
print("--- 확인 전용선 ---")
```

## 자료형과 기본 자료형

파이썬 프로그램도 수많은 자료를 다룹니다. 구분된 종료를 자료형이라고 부릅니다. 기본적인 자료형으로는 문자열, 숫자, 불이 있습니다.

문자열: 메일 제목, 메시지 내용 등
숫자: 물건의 가격, 학생의 성적 등
불: 친구의 로그인 상태 등


### 자료형 확인하기

자료형이란 자료의 형식을 말합니다. 파이선에서 자료의 형식을 확인할 때는 type()함수를 사용합니다. 

type() 함수를 사용하는 예
```python
print(type("안녕하세요"))
<class 'str'>
print(type(273))
<class 'int'>
```
### 문자열 만들기

프로그래밍 언어에서는 글자들이 나열된 것을 문자열이라고 부릅니다. 문자열은 영어로 string이라고 부릅니다.

큰따옴표, 작은따옴표 둘 다 사용 가능한데 이는 구문 오류를 피하기 위함입니다.

큰따옴표를 문자열 내부에 넣고 싶을 때는 작은따옴표로 문자열을 만들어 주면 됩니다.
```python
print('"안녕하세요"라고 말했습니다')
```

반대로 작은따옴표를 문자열 내부에 넣고 싶을 때는 큰따옴표로 문자열을 만들어 주면 됩니다.
```python
print("'안녕하세요'라고 말했습니다")
```

#### 이스케이프 문자를 사용해 문자열 만들기

이스케이프 문자는 역슬래시 기호와 함께 조합해서 사용하는 특수한 문자를 의미합니다. 
이스케이프 문자를 기호 앞에 사용하면 기호 문자 본연의 의미를 가집니다.

이스케이프를 사용하여 따옴표를 온전하게 사용하는 예
```python
print("\"안녕하세요\"라고 말했습니다")
#"안녕하세요"라고 말했습니다
print('\'안녕하세요\'라고 말했습니다')
#'안녕하세요'라고 말했습니다.
```

이 외에도 다양한 이스케이프 문자가 있습니다.

\n : 줄바꿈을 의미합니다.
\t : 탭을 의미합니다.

이스케이프 문자(\t)로 표 형식을 만드는 예입니다.
```python
print("이름\t나이\t지역")
print("윤인성\t25\t강서구")
print("윤아린\t24\t강서구")
print("구름\t3\t강서구")
```

## 여러 줄 문자열 만들기

\n 이스케이프 문자를 사용하여 줄바꿈을 하면 한 줄에 긴 코드를 입력했을 때 읽기가 힘들뿐더러 한 줄에 줄바꿈 문자도 많아 어떤 부분에서 줄바꿈이 일어나는지 확인하기 번거롭습니다.
파이썬은 이때 여러 줄 문자열이라는 기능을 지원합니다. 큰따옴표 또는 작은따옴표를 세 번 반복해 입력한 후 문자열을 입력하면 엔터를 누르는 곳 마다 줄바꿈이 일어나 코드를 훨씬 더 쉽게 읽을 수 있습니다.

여러 줄 문자열 """, '''을 사용한 예입니다.
```python
print("""동해물과 백두산이 마르고 닳도록
하느님이 보우하사 우리나라 만세
대한으로 길이 보전하세""")
```

#### 줄바꿈 없이 문자열 만들기

위와 같이 여러 줄 문자열을 사용하면 첫 번째 줄과 마지막 줄에 의도하지 않은 줄바꿈이 들어가게 됩니다.
이때 따옴표 뒤에 이스케이프 문자를 사용하여 코드를 쉽게 보려고 한 줄바꿈이라는 의미를 주면서 첫 번째줄과 마지막 줄의 의도치 않은 줄바꿈을 없애줄 수 있습니다.

## 문자열 연산

### 문자열 연결 연산자 +

문자열에는 + 기호로 문자열 연산을 적용할 수 있습니다.

다음은 + 문자열 연결 연산자를 사용한 예시 코드입니다.
```python
print("안녕" + "하세요")
#안녕하세요
print("안녕하세요"+"!")
#안녕하세요!
```

문자열은 무조건 문자열끼리 +기호를 사용해야하고 숫자라 하더라도 문자열과 함께 +연산하려면 큰따옴표를 붙여 문자열로 인식시켜야합니다.
숫자를 더할 때는 숫자와 숫자 사이에 + 기호를 사용해서 연산해야 합니다.

### 문자열 반복 연산자 *

문자열을 숫자와 * 연산자로 연결하면 문자열을 반복할 수 있습니다.
다음은 문자열을 숫자와 * 연산자로 연결하여 반복하는 예시 코드입니다.
```python
print("안녕하세요" * 3)
#안녕하세요안녕하세요안녕하세요
```
순서를 바꿔서 숫자 * 문자열과 같이 입력해도 됩니다.

### 문자 선택 연산자(인덱싱): []

문자 선택 연산자는 문자열 내부의 문자 하나를 선택하는 연산자입니다. 이때 대괄호 [] 안에는 선택할 문자의 위치를 지정하며, 이 숫자를 인덱스라고 부릅니다.
인덱스의 유형은 크게 두가지로 0부터 세는 제로 인덱스, 다른 하나는 1부터 세는 원 인덱스로 구분합니다.
파이썬은 제로 인덱스 유형을 사용하는 언어로 문자열의 위치를 셀 때 0부터 세어 주어야 합니다.

다음은 문자 선택 연산자의 결과를 출력하는 코드입니다.
string_operator01.py
```python
print("문자 선택 연산자에 대해 알아봅시다")
print("안녕하세요[0]")
print("안녕하세요[1]")
print("안녕하세요[2]")
print("안녕하세요[3]")
print("안녕하세요[4]")
```

## 문자열 범위 선택 연산자(슬라이싱): [:]

문자열의 특정 범위를 선택할 때 사용하는 연산자도 있습니다. 범위는 대괄호 안에 위치를 콜론으로 구분해서 지정합니다.
뒤의 값을 생략할 때는 자동으로 가장 최대 위치(마지막 글자)까지, 앞의 값을 생략할 때는 가장 앞쪽의 위치(첫 번째 글자)까지 지정합니다.

다음은 문자열 범위 선택자(슬라이싱)을 사용하는 예시코드입니다.
```python
print("안녕하세요"[1:3])
print("안녕하세요"[1:])
print("안녕하세요"[:4])
```

꼭 기억해야 할 것은 문자열 선택 연산자로 슬라이싱을 하더라도 원본은 변하지 않는다는 것입니다.

## IndexError(index out of range) 예외

프로그래밍을 할 때 가장 많이 만나는 예외로 IndexError 예외는 리스트/문자열의 수를 넘는 요소/글자를 선택할 때 발생합니다.

IndexError 예외의 예시 코드입니다.
```python
print("안녕하세요"[10])
```

## 문자열의 길이 구하기

문자열의 길이를 구할 때는 len() 함수를 사용한비다. len()도 식별자 뒤에 괄호가 있으므로 함수 입니다
다음은 len()함수를 사용해서 문자열의 길이(문자의 개수)를 세어주는 예시코드입니다.
```python
print(len("안녕하세요"))
5
```
# 숫자

## 숫자의 종류

숫자를 만들려면 그냥 단순히 숫자를 입력하면 됩니다. print() 함수의 괄호 안에 숫자를 입력하면 숫자를 출력합니다.
소수점이 없는 숫자를 정수형(integer)이라고 하고, 소수점이 있는 숫자를 실수형 또는 부동 소수점(floating point)이라고 합니다.

## 숫자 연산자

사칙 연산자에는 기본적으로 덧셈(+), 뺄셈(-), 곱셉( * ), 나눗셈(/)과 같은 사칙연산자가 있습니다.

## 정수 나누기 연산자 : //

정수 나누기 연산자 //는 숫자를 나누고 소수점 이하의 자릿수를 떼어 버린 후, 정수 부분만 남기는 정수 나누기 연산자입니다.

```python
print("3/2=", 3/2)
3/2 = 1.5
print("3//2=", 3//2)
3//2 = 1
```

## 나머지 연산자 : %

나머지 연산자는 A를 B로 나누었을 때 남은 나머지를 구하는 연산자입니다.
```python
print("5%2 =", 5%2)
5%2 = 1
```

## 제곱 연산자 : **

숫자를 제곱하는 ** 연산자가 있습니다. 2를 4번 곱하는 것을 파이썬에서는 2**4로 씁니다.
```python
print("2**1 = ", 2**1)
2**1 = 2
print("2**2 = ", 2**2)
2**2 = 4
print("2**3 = ", 2**3)
2**3 = 8
print("2**4 = ", 2**4)
2**4 = 16
```

## 연산자의 우선순위

연산자에는 우선순위가 존재합니다. 숫자를 계산할 때는 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선합니다.
먼저 연산하고 싶은 부분은 괄호로 감싸주는 데 연산자 우선순위가 확실한 경우에도 괄호로 감싸 주는 것이 좋습니다.

## TypeError 예외

문자열과 숫자를 + 연산자로 연결한 예시입니다.
```python
string = "문자열"
number = 273
string + number
```

문자열은 + 연산자를 '문자열 연결 연산자'로 사용하려고 하고, 숫자는 + 연산자를 '덧셈 연산자'로 사용하려다 보니 충돌이 발생합니다.


# 변수와 입력

변수는 값을 저장할 때 사용하는 식별자입니다. pi라는 이름의 상자(저장 공간)을 만든 후, pi 상자 내부에 값을 넣어 놨다가 필요할 때 이를 호출하여 사용합니다. 이때 pi를 '변수'라고 하며 숫자뿐만 아니라 모든 자료형을 저장할 수 있습니다.

## 변수 만들기/사용하기

1. 변수를 선언하는 방법

변수를 생성하는 것을 의미합니다. pi를 '사용하겠다'라고 선언하는 것을 말합니다.

2. 변수에 값을 할당하는 방법

변수에 값을 넣는 것을 의미합니다. pi=3.14159265 이때 = 기호는 '같다'는 의미가 아니라 우변의 값을 좌변에 '넣겠다', '할당하겠다'를 의미합니다.

3. 변수를 참조하는 방법

변수에서 값을 꺼내는 것을 의미합니다. 변수 안에 있는 값을 사용하는 것을 '변수 참조'라고 합니다.

다음은 pi라는 변수를 선언하고 이를 참조하는 방법을 사용해 원의 둘레와 넓이를 구하는 코드입니다.

variable.py
```python
# 변수 선언과 할당

pi = 3.14159265
r = 10

# 변수 참조
print("원주율 =", pi)
print("반지름 =", r)
print("원의 둘레 =", 2*pi*r) # 원의 둘레
print("원의 넓이 =", pi*r*r) # 원의 넓이
```

## 파이썬의 유연성

C, C++, JAVA, C# 등에서는 기본적으로 변수를 사용할 때 변수의 자료형을 미리 선언해줘야 합니다. 하지만 파이썬은 다른 프로그래밍 언어와는 다르게 변수에 자료형을 지정하지 않습니다. 
유연해서 좋다고 말할 수도 있지만, 이러한 유연성 때문에 변수에 어떠한 자료형이 들어 있는지 모르고 실수해서 실행 중에 TypeError를 발생할 확률이 높습니다. 그러므로 하나의 변수에는 되도록 하나의 자료형을 넣어 활용하는 것이 좋습니다.

## 복합 대입 연산자

변수를 활용하면 기존의 연산자와 조합해서 사용할 수 있는 연산자가 있는데 이를 복합 대입 연산자라고 합니다.
복합 대입 연산자는 자료형에 적용하는 기본 연산자와 = 연산자를 함께 사용해 다음과 같이 구성하는 연산자입니다.

복합 대입 연산자의 예

+= : 숫자 덧셈 후 대입
-= : 숫자 뺄셈 후 대입
\*= : 숫자 곱셈 후 대입
/= : 숫자 나눗셈 후 대입
%= 숫자의 나버지를 구한 후 대입
\*\*= : 숫자 제곱 후 대입

다음은 number 변수에 숫자 100을 할당하고 10, 20, 30을 덧셈 복합 대입 연산자를 사용하는 예시 코드입니다.
```python
number = 100
number += 10 # number = number + 10 결과 : 110
nubmer += 20 # number = number + 20 결과 : 130
number += 30 # number = number + 30 결과 : 160
print("number =", number)
number= 160
```

다음은 문자열 복합 대입 연산자를 활용한 예시 코드입니다.
```python
string = "안녕하세요"
string += "!"
string += "!"
print("string =", string)
string = 안녕하세요!!!
```
## 사용자 입력 : input()

실무에서 프로그램을 만들 때는 명령 프롬프트에 글자를 입력하고 그 입력을 읽어 활용하는 경우가 드물지만, 프로그램을 공부하는 과정에서는 사용자로부터 입력을 받아 여러 가지 프로그램을 만들어 보는 것이 좋습니다. 파이썬은 명령 프롬프트에서 사용자로부터 데이터를 입력받을 때 input()함수를 사용합니다.

## input() 함수로 사용자 입력받기

사용자로부터 데이터를 입력받기 위해 다음 코드를 입력합니다. 이때 input 함수 괄호 안에 입력한 내용을 프롬프트 문자열이라고 하며, 사용자로부터 입력을 요구하는 안내 내용을 포함합니다.

```python
input("인사말을 입력하세요> ")
```
실행하면 다음과 같이 "인사말을 입력하세요> "라는 문자열이 뜨고 프로그램이 종료되지 않은 상태에서 대기가 됩니다. 이렇게 프로그램이 실행 도중에 잠시 멈추는 것을 블록이라고 하는데, input()함수가 사용자에게 자료 입력을 요구하면서 코드 진행을 블록하고 있다고 할 수 있습니다.

사용자가 입력한 내용은 input 함수의 결과로 나오는데, 이 값은 다른 변수에 대입해서 사용할 수 있습니다. print() 함수를 사용해서 변수에 제대로 대입되었는지 확인하는 코드입니다.
```python
string = input("인사말을 입력하세요>")
인사말을 입력하세요> 안녕하세요 enter키 
print(string)

안녕하세요
```

## input() 함수의 입력 자료형

앞서 input()함수의 결과를 string이라는 변수에 대입했는데, 자료형을 알아볼 때는 type()함수를 사용합니다.

```python
string = "안녕하세요"
print(type(string))
<class 'str>
```
string 변수에는 "안녕하세요"라는 문자열을 입력해 대입했으니 다영히 자료형도 문자열입니다.

다음은 숫자를 입력하고 숫자를 출력하는 코드입니다.
```python
number = input("숫자를 입력하세요>)
숫자를 입력하세요> 12345 enter키 입력
print(number)
12345
```

그렇다면 입력받은 number의 자료형은 어떻게 될까요
```python
print(type(nubmer))
<class 'str'>
```

input()함수는 사용자가 무엇을 입력해도 결과는 무조건 문자열 자료형입니다. number에 대입한 12345도 'str'로 확인이 되는 것을 알 수 있습니다.

## 문자열을 숫자로 바꾸기

input()함수의 입력 자료형은 항상 문자열이기 때문에 입력받은 문자열을 숫자로 변환해야 숫자 연산에 활용할 수 있습니다. 영어로는 캐스트 cast 라고 하는데, 영어로도 자주 언급되므로 기억하는 게 좋습니다.

문자열을 숫자 자료형으로 변환해야 하는 경우는 매우 많습니다. 예를 들어, 파이썬을 사용해 인터넷에서 환율 정보를 가져온다고 합시다. 이때도 인터넷에 있는 글자는 모두 문자열이므로 숫자로 변환해야 활용할 수 있습니다.

문자열을 숫자로 변환할 때는 다음과 같은 함수를 사용합니다.

int()함수 : 문자열을 int자료형으로 변환합니다. int는 정수를 의미합니다.
float()함수 : 문자열을 float자료형으로 변환합니다. float는 실수 또는 부동 소수점을 의미합니다.

int()함수 활용하는 예시 코드입니다.

int_convert.py
```python
string_a = input("입력A> ")
int_a = int(string_a)

string_b = input("입력B> ")
int_b = int(string_b)

print("문자열 자료:", string_a + string_b)
print("숫자 자료:", int_a + int_b)
```

int()함수와 float()함수 활용하기

int_float01.py
```python
output_a = int("52")
output_b = float("52.273")

print(type(output_a), output_a)
print(type(output_b), output_b)
```

## ValueError 예외

첫째, 숫자가 아닌 것을 숫자로 변환하려고 할 때

int("안녕하세요")
float("안녕하세요")

이와 같은 코드를 실행하면 곧바로 예외가 발생합니다. "안녕하세요"라는 문자열은 int() 함수로 변환할 수 없는 값이기 때문입니다. int() 함수와 float() 함수는 매개변수로 변환할 수 없는 형태가 들어가면 항상 오류를 발생시킵니다.

둘째, 소수점이 있는 숫자 형식의 문자열을 int()함수로 변환하려고 할 때

int("52.273")

int는 정수인데, 부동 소수점이 있는 자료를 정수로 바꾸라고 하면 이 또한 에러를 발생합니다.

## 숫자를 문자열로 바꾸기

문자열을 숫자로 변환하는 것처럼 숫자를 문자열로 변환하는 것도 가능합니다. 사실 문자열로 변환하는 방법은 매우 다양합니다. 여기서는 str()함수를 사용하는 방법을 살펴보겠습니다.
str()함수는 앞서 했던 int()함수 그리고 float() 함수와 비슷한 형태를 가집니다. 즉 다른 자료형의 값을 str()함수의 매개변수에 넣으면 문자열로 변환됩니다.

str(다른 자료형)

다음은 str()함수를 사용해 숫자를 문자열로 변환하는 예시코드입니다.

str.py
```python
output_a = str(52)
output_b = str(52.273)
print(type(output_a), output_a)
print(type(output_b), output_b)
```

# 숫자와 문자열의 다영한 기능

## 문자열의 format() 함수

format() 함수로 숫자를 문자열로 변환하는 몇 가지 형태를 살펴보겠습니다.

format() 함수는 문자열이 가지고 있는 함수입니다. 중괄호 {}를 포함한 문자열 뒤에 마침표(.)를 찍고 format() 함수를 사용하는 데, 중괄호의 개수와 format 함수 괄호 안 매개변수의 개수는 반드시 같아야합니다.

"{}".format(10)
"{} {}".format(10, 20)
"{} {} {} {}".format(101, 202, 303, 404, 505)

이러한 형태로 함수를 사용하면 앞쪽에 있는 문자열의 {} 기호가 format() 함수 괄호 안에 있는 매개변수로 차례로 대치되면서 숫자가 문자열이 되는 것입니다. 즉 아래의 예시에서 10은 문자열의 중괄호 부분에 들어가 숫자 10이 문자열 "10"이 되는 것입니다.

다음은 format() 함수로 숫자를 문자열로 변환하는 예시코드입니다.

format_basic.py
```python
  # format() 함수로 숫자를 문자열로 변환하기
string_a = "{}".format(10)

# 출력하기
print(string_a)
print(type(string_a))   
```

다음은 {} 기호 양쪽에 다른 문자열을 같이 넣은 형태, {} 기호와 매개변수를 여러개 넣은 형태를 실행해보겠습니다.

format01.py
```python
# format() 함수로 숫자를 문자열로 변환하기
format_a = "{}만 원".format(5000)
format_b = "파이썬 열공하여 첫 연봉 {}만원 만들기".format(5000)
format_c = "{} {} {}".format(3000, 4000, 5000)
format_d = "{} {} {}".format(1, "문자열", True)

# 출력하기
print(format_a) 
print(format_b)
print(format_c)
print(format_d)
```

## IndexError 예외

{} 기호의 개수가 format() 함수의 매개변수 개수보다 많으면 IndexError 예외가 발생합니다. 아래의 예시에서 첫 번째는 매개변수가 {}보다 많은  경우로 {} 개수만큼 적용되고 나머지 매개변수는 버려져 아무 문제 없이 실행됩니다. 두 번째는 {}가 매개변수보다 많은 경우로 IndexError 예외가 발생합니다.

```python
"{} {}".format(1, 2, 3, 4, 5)
'1 2'
"{} {} {}".format(1, 2)
>IndexError 발생
```

## format() 함수의 다양한 기능

정수 출력의 다양한 형태

정수를 특정 칸에 출력하기

format02.py
```python
# 정수
output_a = "{:d}".format(52)

# 특정 칸에 출력하기
output_b = "{:5d}".format(52)  # 5칸
output_c = "{:10d}".format(52)  # 10칸

# 빈칸을 0으로 채우기
output_d = "{:05d}".format(52)  # 양수
output_e = "{:05d}".format(-52)  # 음수

print("# 기본")
print(output_a)
print(output_b)
print(output_c)
print("# 빈칸을 0으로 채우기")
print(output_d)
print(output_e)
```

다음은 기호를 붙여 출력하는 예시코드입니다.

format03.py
```python
# 기호와 함께 출력하기
output_f = "{:+d}".format(52)  # 양수
output_f = "{:+d}".format(-52)  # 음수
output_f = "{: d}".format(52)  # 양수: 기호 부분 공백
output_f = "{: d}".format(-52)  # 음수: 기호 부분 공백

print("# 기호와 함께 출력하기")
print(output_f)
print(output_g)
print(output_h)
print(output_i)
```

기호와 공백을 조합할 때는 = 기호를 앞에 붙일 수 있습니다. 이는 5칸의 공간을 잡았을 때 기호를 빈칸 앞에 붙일 것인지, 숫자 앞에 붙일 것인지 지정하는 기호입니다.

format04.py
```python
output_h = "{:+5d}".format(52)  # 기호를 뒤로 밀기: 양수
output_i = "{:+5d}".format(-52)  # 기호를 뒤로 밀기: 음수
output_j = "{:=+5d}".format(52)  # 기호를 뒤로 밀기: 양수
output_k = "{:=+5d}".format(-52)  # 기호를 뒤로 밀기: 음수
output_l = "{:+05d}".format(52)  # 0으로 채우기 : 양수
output_m = "{:+05d}".format(-52)  # 0으로 채우기 : 음수

print("# 조합하기")
print(output_h)
print(output_i)
print(output_j)
print(output_k)
print(output_l)
print(output_m)
```

## 부동 소수점 출력의 다양한 형태

일단 float 자료형 출력을 강제로 지정할 때는 {:f}를 사용하고 이전에 살펴보았 던 형태들을 적용할 수 있습니다.

format05.py
```python
output_a = "{:f}".format(52.273)
output_b = "{:15f}".format(52.273)  # 15칸 만들기
output_c = "{:+15f}".format(52.273)  # 15칸에 부호 추가하기
output_d = "{:+015f}".format(52.273)  # 15칸에 부호 추가하고 0으로 채우기

print(output_a)
print(output_b)
print(output_c)
print(output_d)
```

소수점 아래 자릿수를 지정하는 예시코드입니다.

format06.py
```python
output_a = "{:15.3f}".format(52.273)
output_b = "{:15.2f}".format(52.273)
output_c = "{:15.1f}".format(52.273)

print(output_a)
print(output_b)
print(output_c)
```

15칸을 잡고 소수점을 각각 3자리, 2자리, 1자리로 출력합니다. 이때 자동으로 반올림도 일어납니다.

## 의미없는 소수점 제거하기

0.0과 0을 출력했을 때 내부적으로 자료형이 다르므로 서로 다른 값으로 출력합니다. 의미 없는 0을 제거한 후 출력하고 싶을 때 {:g} 를 사용합니다.

format07.py
```python
output_a = 52.0
output_b = "{:g}".format(output_a)
print(output_a)
print(output_b)
```

## 대소문자 바꾸기 : upper() 와 lower()

upper()함수는 문자열의 알파벳을 대문자로, lower()함수는 문자열의 알파벳을 소문자로 만듭니다.

a = "Hello Python Programming ...!"
a.upper()
'HELLO PYTHON PROGRAMMING ...!
a.lower()
'hello python programming ...!

이 때 upper(), lower() 함수는 원본을 변하시키지 않는 비파괴적 함수입니다.

## 문자열 양옆의 공백 제거하기 : strip()

strip() 함수는 문자열 양옆의 공백을 제거합니다. 왼쪽의 공백을 제거하는 lstrip() 함수와 오른쪽의 공백을 제거하는 rstrip()함수도 있습니다. 이때 공백이란 "띄어쓰기", "탭", "줄바꿈" 모두를 포합합니다.

큰따옴표 또는 작은따옴표를 세 번 반복한 기호는 여러 줄 문자열을 입력할 때 사용하는 것으로 이때 의도치 않는 줄바꿈이 들어갑니다. 이때 strip() 함수를 사용해서 쉽게 제거 할 수 있습니다.

이렇게 strip()함수를 사용하여 공백 제거를 하는 기능을 trim이라고도 부릅니다. 공백을 제거할 때는 strip 또는 trim을 활용한다고 기억하는게 좋습니다.

## 문자열의 구성 파악하기 : isOO()

문자열이 소문자로만 구성되있는지 알파벳으로만 구성되어있는지 숫자로만 구성되어있는지 등을 확인할 때는 is로 시작하는 이름의 함수를 사용합니다.

isalnum() : 문자열이 알파벳 또는 숫자로만 구성되어있는지 확인합니다.
isalpha() : 문자열이 알파벳만으로만 구성되어 있는지 ~
isidentifier() : 문자열이 식별자로 사용할수 ~
isdecimal() : 문자열이 정수 형태인지 확인합니다.
isdigit() : 문자열이 숫자로 인식될 수 ~
isspace() : 문자열이 공백으로만 ~
islower() : 문자열이 소문자로만 ~
isupper() : 문자열이 대문자로만 ~

## 문자열 찾기 : find()와 rfind()

문자열 내부에 특정 문자가 어디에 위치하는 지 확인할 때 find()함수와 rfind() 함수를 사용합니다.

find() : 왼쪽부터 찾아서 처음 등장하는 위치를 찾습니다.
rfind() : 오른쪽부터 찾아서 처음 등장하는 위치를 찾습니다.

output_a = "안녕안녕하세요".find("안녕")
print(output_a)
0

output_b = "안녕안녕하세요".rfind("안녕")
print(output_b)
2

## 문자열과 in 연산자

문자열 내부에 어떤 문자열이 있는지 확인하려면 in 연산자를 사용합니다. 출력은 True(맞다) 또는 False(아니다)라고 나옵니다.
print("안녕" in "안녕하세요")
True

print("잘자" in "안녕하세요")
False

## 문자열 자르기 : split()

문자열을 특정한 문자로 자를 때 split()함수를 사용합니다. split 함수 괄호 안의 문자열인 공백(띄어쓰기)을 기준으로 자릅니다

a = "10 20 30 40 50".split(" ")
print(a)
['10', '20', '30', '40', '50' ]

실행결과로 리스트가 나옵니다

# 불 자료형과 if 조건문

## 불 만들기 : 비교 연산자

Boolean은 불린 또는 불리언이라는 발음으로 부릅니다. 불은 오직 True(참)과 False(거짓) 값만 가질 수 있습니다.
불은 비교 연산자를 통해 만들 수 있습니다. 

== : 같다
> : 크다
!= : 다르다
<= : 작거나 같다
< : 작다
>= : 크거나 같다

비교 연산자는 숫자 또는 문자열에 적용할 수 있습니다.

다음은 숫자의 대소 비교를 비교연산자를 이용하는 예시 코드입니다.
```python
print(10 == 100)
False
print(10 != 100)
True
print(10 < 100)
True
print(10 > 100)
False
print(10 <= 100)
True
print(10 >= 100)
False
```

파이썬은 문자열에도 비교 연산자를 적용할 수 있습니다. 
다음은 문자열의 비교 연산자를 이용하는 예시 코드입니다.
```python
print("가방" === "가방")
True
print("가방" != "하마")
False
print("가방" < "하마")
True
print("가방" > "하마")
False
```

가방과 하마를 비교하면 사전 순서로 가방이 앞에 있으므로 가방이 하마보다 작은 값을 갖습니다.

파이썬은 다음과 같은 코드를 사용해 변수의 범위 등도 구할 수 있습니다.
```python
x = 25
print(10 < x < 30)
True
print(40 < x < 60)
False
```

## 불 연산하기 : 논리 연산자

불끼리는 논리 연산자를 사용할 수 있습니다.
다음과 같은 세 개의 논리 연산자가 있습니다.

not 아니다 : 불을 반대로 전환합니다.
and 그리고 : 피연산자 두 개가 모두 참일 때 True를 출력하며, 그 외는 모두 False를 출력합니다.
or 또는 : 피연산자 두 개 중에 하나만 참이라도 True를 출력하며, 두 개가 모두 거짓일 때만 False를 출력합니다.

## not 연산자

not 연산자는 단항 연산자로, 참과 거짓을 반대로 바꿀 때 사용합니다. 실행하면 단순하게 True와 False가 서로 바뀝니다.

print(not True)
False
print(not False)
True

not 연산자 조합하는 예시코드입니다.

boolean.py
```python
x = 10
under_20 = x < 20
print("under_20:", under_20)
print("not under_20", not under_20)
```

## and 연산자와 or 연산자

and 연산자는 양쪽 변의 값이 모두 참 일때만 True를 결과로 냅니다.

반면 or 연산자는 둘 중 하나만 참이어도 True를 결과로 냅니다.

다음은 and와 or 연산자를 공부하는 예시코드입니다.
```python
print(True and True)
True
print(True and False)
False
print(False and True)
False
print(False and False)
False
print(True or True)
True
print(True or False)
True
print(False or True)
True
print(False or False)
False
```

## if 조건문이란?

if 조건문은 조건에 따라 코드를 실행하거나, 실행하지 않게 만들고 싶을 때 사용하는 구문입니다. 이는 코드의 실행 흐름을 변경한다는 뜻입니다. 이렇게 조건을 기반으로 실행의 흐름을 변경하는 것을 조금 어려운 용어로 조건 분기라고 부릅니다.

if 조건문의 기본적인 구조는 다음과 같습니다.

if 불 값이 나오는 표현식: 
    불 값이 참일 때 실행할 문장
    불 값이 참일 때 실행할 문장
    
다음은 if문을 사용하여 양수를 입력하면 "양수입니다"를, 음수를 입력하면 "음수입니다"를, 0을 입력하면 "0입니다"를 출력하는 예시코드입니다.
```python
# 입력을 받습니다.
number = input("정수 입력> ")
number = int(number)

# 양수 조건
if number > 0:
    print("양수입니다.")

# 음수 조건
if number < 0:
    print("음수입니다.")

# 0 조건
if number == 0:
    print("0입니다.")
```

## 날짜/시간 활용하기

여러 가지 조건문 중 몇 가지를 더 살펴보겠습니다. 
먼저 시간을 조건으로 구분하여 오전인지 오후인지를 출력하는 프로그램을 작성해 보겠습니다.

다음은 날짜/시간을 출력하는 예시코드입니다.
```python
# 날짜/시간과 관련된 기능을 가져옵니다.
import datetime

# 현재 날짜/시간을 구합니다.
now = datetime.datetime.now()

# 출력합니다.
print(now.year, "년")
print(now.month, "월")
print(now.day, "일")
print(now.hour, "시")
print(now.minute, "분")
print(now.second, "초")
```

이전에 배웠던 format() 함수를 활용하여 날짜를 한눈에 볼 수 있게 출력하는 예시 코드입니다.
```python
# 날짜/시간과 관련된 기능을 가져옵니다.
import datetime

# 현재 날짜/시간을 구합니다.
now = datetime.datetime.now()

# 출력합니다.
print("{}년 {}월 {}일 {}분 {}초".format(
    now.year,
    now.month,
    now.day,
    now.hour,
    now.minute,
    now.minute,
    now.second
))
```

다음은 오전과 오후를 구분하는 프로그램의 예시코드입니다.

```python
# 날짜/시간과 관련된 기능을 가져옵니다.
import datetime

# 현재 날짜/시간을 구합니다.
now = datetime.datetime.now()

# 오전 구분
if now.hour < 12:
    print("현재 시각은 {}시로 오전입니다!".format(now.hour))

# 오후 구분
if now.hour >= 12:
    print("현재 시각은 {}시로 오후입니다!".format(now.hour))
```

다음은 계절을 구분하는 프로그램의 예시코드입니다.

```python
# 날짜/시간과 관련된 기능을 가져옵니다.
import datetime

# 현재 날짜/시간을 구합니다.
now = datetime.datetime.now()

# 봄 구분
if 3 <= now.month <= 5:
    print("이번 달은 {}월로 봄입니다!".format(now.month))

# 여름 구분
if 6 <= now.month <= 8:
    print("이번 달은 {}월로 여름입니다!".format(now.month))
xx`
    print("이번 달은 {}월로 가울입니다!".format(now.month))

# 겨울 구분
if now.month == 12 or 1 <= now.month <= 2:
    print("이번 달은 {}월로 겨울입니다!".format(now.month))
```

다음은 끝자리로 짝수와 홀수 구분하는 프로그램의 예시 코드입니다.

```python
# 입력을 받습니다.
number = input("정수 입력> ")

# 마지막 자리 숫자를 추출
last_character = number[-1]

# 숫자로 변환하기
last_number = int(last_character)

# 짝수 확인
if last_number == 0 \
        or last_number == 2 \
        or last_number == 4 \
        or last_number == 6 \
        or last_number == 8:
    print("짝수입니다.")

# 홀수 확인
if last_number == 1 \
        or last_number == 3 \
        or last_number == 5 \
        or last_number == 7 \
        or last_number == 9:
    print("홀수입니다.")
```

다음은 in 문자열 연산자를 활용해서 짝수와 홀수 구분하는 프로그램의 예시코드입니다.

```python
# 입력을 받습니다.
number = input("정수 입력> ")
last_character = number[-1]

# 짝수 조건
if last_character in "02468":
    print("짝수입니다.")

# 홀수 조건
if last_character in "13579":
    print("홀수입니다.")
```

다음은 나머지 연산자를 활용해서 짝수와 홀수 구분하는 프로그램의 예시코드입니다.
```python
# 입력을 받습니다.
number = input("정수 입력> ")
number = int(number)

# 짝수 조건
if number % 2 == 0:
    print("짝수입니다.")

# 홀수 조건
if number % 2 == 1:
    print("홀수입니다.")
```

# if~else와 elif 구문

정반대되는 상황에서 두 번이나 조건을 비교해야 하는 것을 프로그램의 관점에서 봤을 때 낭비라고 할 수 있습니다.

## else 조건문의 활용

파이썬은 else 구문이라는 기능을 제공합니다. else 구문은 if 조건문 뒤에 사용하며, if 조건문의 조건이 거짓일 때 실행되는 부분입니다.

if 조건 :
    조건이 참일 때 실행할 문장
else:
    조건이 거짓일 때 실행할 문장
    
다음은 if 조건문에 else 구문을 추가해서 짝수와 홀수를 구분하는 프로그램의 예시코드입니다.
```python
# 입력을 받습니다.
number = input("정수 입력> ")
number = int(number)

# 조건문을 사용합니다.
if number % 2 == 0:
    # 조건이 참일 때, 즉 짝수 조건
    print("짝수입니다.")
else:
    # 조건이 거짓일 때, 즉 홀수 조건
    print("홀수입니다.")
```

조건이 오로지 두 가지로만 구분될 때 if else 구문을 사용하면 조건 비교를 한 번만 하므로 이전의 코드보다 두 배 효율적이라고 할 수 있습니다. 사실 간단한 프로그램에서는 이런 차이가 크지 않지만 조건 비교를 100만 번, 100억 번 저이도 한다고 가정하면 시간 차이가 크게 발생합니다.

## elif 구문

그런데 딱 두가지만으로 구분되지 않는 것도 있습니다. 예를 들어 계절만 해도 네 개가 있으며, 요일만 해도 일곱 개가 있습니다. 따라서 세 개 이상의 조건을 연결해서 사용하는 방법이 필요합니다. 그것이 바로 elif 구문입니다.

elif 구문은 if 조건문과 else 구문 사이에 입력하며, 다음과 같은 형태로 사용합니다.

if 조건A:
    조건A가 참일 때 실행할 문장
elif 조건B:
    조건B가 참일 때 실행할 문장
elif 조건C:
    조건C가 참일 때 실행할 문장
else:
    모든 조건이 거짓일 때 문장
    
다음은 현재 월을 구하고 이를 기반으로 계절을 구하는 elif 구문을 사용한 프로그램의 예시코드입니다.
```python
# 날짜/시간과 관련된 기능을 가져옵니다.
import datetime

# 현재 날짜/시간을 구하고
# 쉽게 사용할 수 있게 월을 변수에 저장합니다.
now = datetime.datetime.now()
month = now.month

# 조건문으로 계절을 확인합니다.
if 3 <= month <= 5:
    print("현재는 봄입니다.")
elif 6 <= month <= 8:
    print("현재는 여름입니다.")
elif 9 <= month <= 11:
    print("현재는 가을입니다.")
else:
    print("현재는 겨울입니다.")
```

## False로 변환되는 값

if 조건문이 매개변수에 불이 아닌 다른 값이 올 때는 자동으로 이를 불로 변환해서 처리합니다. 따라서 어떤 값이 True로 변환되고, 어떤 값이 False로 변환되는지 알고 있어야 코드를 이해할 수 있습니다. False로 변환되는 값은 None, 숫자 0과 0.0 빈 컨테이너(빈 문자열, 빈 바이트열, 빈 리스트, 빈 튜플, 빈 딕셔너리 등)입니다. 이 외에는 모두 True로 변환되므로 위에 언급한 세 가지만 기억하세요.

False로 변환되는 값들의 예시코드입니다.
```python
print("# if 조건문에 0 넣기")
if 0:
    print("0은 True로 반환됩니다.")
else:
    print("0은 False로 반환됩니다.")
print()

print("# if 조건문에 빈 문자열 넣기")
if "":
    print("0은 True로 반환됩니다.")

else:
    print("0은 False로 반환됩니다.")
```

## pass 키워드

프로그래밍을 하다 보면 일단 프로그래밍의 전체 골격을 잡아 놓고 내부에서 처리할 내용은 차근차근 생각하며 만들겠다는 의도로 다음과 같이 코딩하는 경우가 많습니다. 이때 골격은 일반적으로 조건문, 반복문, 함수, 클래스 등의 기본 구문을 말합니다.

다음은 나중에 구현하려고 비워 둔 구문의 예시 코드입니다.

```python
# 입력을 받습니다.
number = input("정수 입력> ")
number = int(number)

# 조건문 사용
if number > 0:
    # 양수일 때 : 아직 미구현 상태입니다.
else:
    # 음수일 때 : 아직 미구현 상태입니다.
```

다른 프로그래밍 언어에서는 위와 같이 아무 내용을 작성하지 않아도 실행이 정상적으로 되지만, 파이썬의 경우에는 if 조건문 사이에는 무조건 들여쓰기 4칸을 넣고 코드를 작성해야만 구문이 성립되기 때문에 위와 같이 작성한 경우에는 IndentationError를 발생합니다.

IndentationError는 '들여쓰기가 잘못되어 있다'라는 의미인데 그렇기 때문에 if 구문 사이에는 어떤 내용이라도 넣어 줘야 합니다. 다음과 같이 0을 넣어도 일단 실행은 정상적으로 됩니다.

if number > 0:
    0
else:
    0

하지만 이렇게 0을 넣어놓은 상태의 코드를 다른 개발자들이 보면 "왜 0이 있지?"라고 이상하게 생각할 수 있습니다. 그래서 파이썬에서는 이러한 고민을 덜어주기 위해 pass라는 키워드를 제공합니다. 코드를 살펴보던 중 pass 키워드를 만나면 "진짜 아무것도 안함" 또는 "곧 개발하겠음" 이라는 의미로 생각하면 됩니다.

다음은 pass 키워드를 사용한 미구현 부분 입력을 하는 프로그램의 예시코드입니다.
```python

number = input("정수 입력> ")
number = int(number)

# 조건문 사용
if number > 0:
    # 양수일 때 : 아직 미구현 상태입니다.
    pass
else:
    # 음수일 때 : 아직 미구현 상태입니다.
    pass
```

## raise NotImplementedError

pass 키워드를 입력해 놨어도 내일이면 잊어버리는 경우가 많습니다. 이후에 배우는 raise 키워드와 미구현 상태를 표현하는 NotImplementedError를 조합해 raise NotImplementError를 사용하면 "아직 구현하지 않은 부분이에요!"라는 오류를 강제로 발생시킬 수 있습니다.

다음은 raise NotImplementError 키워드를 사용하여 강제로 오류를 발생시키는 프로그램의 예시코드입니다.
```python
# 입력을 받습니다.
number = input("정수 입력> ")
number = int(number)

# 조건문 사용
if number > 0:
    # 양수일 때 : 아직 미구현 상태입니다.
    raise NotImplementedError
else:
    # 음수일 때 : 아직 미구현 상태입니다.
    raise NotImplementedError
```

# 리스트와 반복문

리스트란 사전적 의미는 '목록'이며, 파이썬에서 리스트의 의미는 여러가지 자료를 저장할 수 있는 자료입니다. 지금까지 활용한 숫자나 문자, 수식 등이 개별적인, 독립적인 '자료'였다면 리스트는
이러한 자료들을 모아서 사용할 수 있게 해주는 특별한 형태의 자료를 말합니다.

## 리스트 선언하고 요소에 접근하기

파이썬에서 리스트를 생성하는 방법은 대괄호[]에 자료를 쉼표로 구분해서 입력합니다.
대괄호[] 내부에 넣는 자료를 요소라고 하고 영어로는 element라고 합니다. 

리스트는 한 가지 자료형만으로 구성할 수도 있고, 여러 종류의 자료형으로 구성할 수도 있습니다.

다음은 여러 종류의 자료형(숫자, 문자열, 불)로 리스트를 구성하는 예시 코드입니다.
```python
list_a = [273, 32, 103, "문자열", True, False]
```

리스트 기호인 대괄호[] 안에 들어간 숫자를 인덱스라고 부릅니다.
```python
list_a = [273, 32, 103, "문자열", True, False]
list_a[0]
273
list_a[1]
32
list_a[2]
103
list_a[3]
"문자열"
list_a[1:3]
[32, 103]
```

list_a[1:3]은 문자열 범위 선택자에서 설명했듯이 1번째 글자부터 3번째 글자를 선택하는 것이 아니라 그 앞에 숫자, 2번째 글자까지 선택합니다. 그러므로 결과는 [32, 103]이 출력됩니다.
리스트의 특정 요소는 변경할 수도 있습니다.
```python
list_a = [273, 32, 103, "문자열", True, False]
list_a[0] = "변경"
list_a
['변경', 32, 103, '문자열, True, False]
```

리스트는 위와 같은 일반적인 사용법 외에도 다양하게 사용할 수 있는 방범이 많습니다.

1. 대괄호 안에 음수를 넣어 뒤에서부터 요소를 선택할 수 있습니다.

```python
list_a = [273, 32, 103, "문자열", True, False]
list_a[-1]
False
list_a[-2]
True
list_a[-3]
'문자열'
```

2. 리스트 접근 연산자를 다음과 같이 이중으로 사용할 수 있습니다.

아래와 같은 리스트가 있다고 할때 list_a[3]을 지정하면 "문자열"을 꺼내오고 list_a[3][0]을 지정하면 3번째에서 가져온 "문자열"에서 다시 0번째를 가져와 출력합니다.
```python
list_a = [273, 32, 103, "문자열", True, False]
list_a[3]
'문자열'
list_a[3][0]
'문'
```

3. 리스트 안에 리스트를 사용할 수도 있습니다.

아래와 같이 기술하면 list_a 리스트는 세 개를 가지는 리스트로 만들어집니다.
```python
list_a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
list_a[1]
[4, 5, 6]
list_a[1][1]
5
```

## 리스트에서의 IndexError 예외

요소가 존재하지 않는 위치에서 요소를 꺼내려고할 때 예외가 발생합니다.
```python
list_a = [273, 32, 103]
list_a[3]
```
이 때 IndexError가 발생합니다.

## 리스트 연산자 : 연결(+), 반복(*), len()

문자열에 적용할 수 있는 연산자는 리스트에서도 활용할 수 있습니다. 문자열과 리스트는 굉장히 비슷한 자료형으로, 사용할 수 있는 연산자와 함수가 비슷합니다.
 
다음은 리스트 연산자를 사용하는 예시코드입니다.

list01.py
```python
# 리스트를 선언합니다.
list_a = [1, 2, 3]
list_b = [4, 5, 6]

# 출력합니다.
print("# 리스트")
print("list_a =", list_a)
print("list_b =", list_b)
print()

print("# 리스트 기본 연산자")
print("list_a + list_b =", list_a + list_b)
print("list_a * 3 =", list_a * 3)
print()

# 함수
print("# 길이 구하기")
print("len(list_a) =", len(list_a))
```

## 리스트에 요소 추가하기 : append, insert

리스트에 요소를 추가할 때는 두 가지 방법이 있습니다. 한 가지는 append() 함수를 활용하는 것으로, 리스트 뒤에 요소를 추가합니다.

리스트명.append(요소)

다른 한 가지는 insert() 함수를 활용하는 것으로 리스트 중간에 요소를 추가합니다.

리스트명.insert(위치, 요소)

다음은 리스트에 요소 추가하는 예시코드입니다.

list02.py
```python
# 리스트를 선언합니다.
list_a = [1, 2, 3]

# 리스트 뒤에 요소 추가하기
print("# 리스트 뒤에 요소 추가하기")
list_a.append(4)
list_a.append(5)
print(list_a)
print()

# 리스트 중간에 요소 추가하기
print("# 리스트 중간에 요소 추가하기")
list_a.insert(0, 10)
print(list_a)
```

append() 함수와 insert() 함수는 리스트에 요소 하나를 추가합니다. 한 번에 여러 요소를 추가하고 싶을 때는 extend() 함수를 사용합니다. extend() 함수는 매개변수로 리스트를 입력하는데, 원래 리스트 뒤에 새로운 리스트의 요소를 모두 추가해 줍니다.

```python
list_a = [1, 2, 3]
list_a.extend([4, 5, 6])
print(list_a)
[1, 2, 3, 4, 5, 6]
```
extend() 함수는 마치 append() 함수를 세 번 반복 실행한 효과를 가져옵니다.

## 리스트 연결 연산자와 요소 추가의 차이

리스트 연결 연산자와 extend() 함수는 비슷한 형태로 동작합니다. 리스트와 리스트를 연결한다는 기능은 동일한데, 한 가지 큰 차이점이 있습니다.

다음은 리스트 연결 연산자를 사용하는 예시코드입니다.
```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]
list_a + list_b 
[1, 2, 3, 4, 5, 6]
list_a
[1, 2, 3]
list_b
[4, 5, 6]
```
리스트 연결자는 연산 결과로 [1, 2, 3, 4, 5, 6]을 출력하고 있으며, 원본에 어떠한 변화도 없다는 것을 알 수 있습니다.

이어서 extend() 함수를 사용하는 예시코드입니다.
```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]
list_a.extend(list_b)
list_a
[1, 2, 3, 4, 5, 6]
list_b
[4, 5, 6]
```

리스트 연결자만으로는 list_a에 어떠한 영향도 주지 않습니다. 하지만 extend() 함수를 사용하면 list_a에 직접적으로 영향을 줍니다.
리스트 연결자와 같이 원본에 어떠한 영향도 주지 않는 것을 비파괴적이라고 표현하고, append(), insert(), extend() 함수와 같이 리스트에 직접적인 영향을 주는 함수 또는 연산을 파괴적이라고 표현합니다.

원래 자료는 비파괴적으로 사용하는 것이 편리합니다. 비파괴적으로 사용하면 원본도 활용할 수 있고, 새로운 결과도 활용할 수 있으므로 선택지가 더 넓기 때문입니다. 그래서 기본적인 모든 것들은 비파괴적으로 작동합니다.
하지만 리스트는 용량이 매우 클 수도 있습니다. 프로그래밍 언어 입장에서 용량이 얼마나 큰지도 모르는 것을 '원본과 결과'라는 두 가지로 생성하는 것은 위험할 수 있습니다. 그래서 파이썬 프로그래밍 언어는 원본을 직접적으로 조작하는 기능을 제공해서 이러한 위험을 피하는 것입니다.

## 리스트에 요소 제거하기

파이썬은 리스트에서 요소를 제거하는 방법이 많습니다. 리스트의 요소를 제거하는 방법은 크게 두 가지로 나뉩니다.

1. 인덱스로 제거하기
2. 값으로 제거하기

## 1. 인덱스로 제거하기 : del, pop

인덱스로 제거한다는 것은 '리스트의 1번째 요소를 제거해 주세요', '리스트의 2번째 요소를 제거해 주세요' 처럼 요소의 위치를 기반으로 요소를 제거하는 것입니다. del 키워드 또는 pop() 함수를 사용합니다.

del 키워드는 다음과 같은 구문을 사용하며,리스트의 특정 인덱스에 있는 요소를 제거합니다.

del 리스트명[인덱스]

pop() 함수 또한 제거할 위치에 있는 요소를 제거하는데, 매개변수를 입력하지 않으면 마지막 요소를 제거합니다.

리스트명.pop(인덱스)

다음은 del 키워드와 pop() 함수를 사용한 리스트 인덱스 제거 실습코드입니다.

list03.py
```python
list_a = [0, 1, 2, 3, 4, 5]
print("# 리스트의 요소 하나 제거하기")

# 제거 방법[1] - del
del list_a[1]
print("del list_a[1]:", list_a)

# 제거 방법[2] - popO()
list_a.pop(2)
print("pop(2):", list_a)
```

추가로 del 키워드를 사용할 때는 범위를 지정해 리스트의 요소를 한꺼번에 제거할 수도 있습니다.
```python
list_b = [0, 1, 2, 3, 4, 5, 6]
del list_b[3:6]
[0, 1, 2, 6]
```

## 2. 값으로 제거하기 : remove

두 번째 방법은 값으로 제거하는 것입니다. 말 그대로 '리스트 내부에 있는 2를 제거해 주세요'처럼 값을 지정해서 제거하는 것입니다. 이때는 remove() 함수를 사용합니다.

리스트.remove(값)

다음은 remove()함수를 이용해 값으로 제거하는 실습코드입니다.
```python
list_c = [1, 2, 1, 2]
list_c.remove(2)
list_c
[1, 1, 2]
```
remove() 함수로 지정한 값이 리스트 내부에 여러 개 있어도 가장 먼저 발견되는 하나만 제거합니다. 만약 리스트에 중복된 여러 개의 값을 모두 제거하려면 반복문과 조합해서 사용해야 합니다.

## 모두 제거하기 : clear

리스트 내부의 요소를 모두 제거할 때는 clear()함수를 사용합니다.

리스트.clear()

다음은 clear()함수를 이용해 리스트 내부의 요소를 모두 제거하는 실습코드입니다.

```python
list_d = [0, 1, 2, 3, 4, 5]
list_d.clear()
list_d
[]
```

지금까지 살펴보았떤 모든 리스트의 함수들은 파괴적으로 동작합니다.

## 리스트 내부에 있는지 확인하기 : in/not in 연산자

파이썬은 특정 값이 리스트 내부에 있는지 확인하는 방법을 제공합니다. 바로 in 연산자를 활용하는 방법입니다.

값 in 리스트

```python
list_a = [273, 32, 103, 57, 52]
273 in list_a
True
99 in list_a
False
52 in list_a
True
```
리스트 내부에 값이 있으면 True, 없으면 False를 출력한다는 것을 알 수 있습니다. 추가적으로 not in 연산자도 있습니다. not in 연산자는 리스트 내부에 해당 값이 없는지 확인하는 연산자입니다.

```python
list_a = [273, 32, 103, 57, 52]
273 not in list_a
False
99 not in list_a
True
100 not in list_a
True
```

## for 반복문

컴퓨터에 반복 작업을 시키느 방법은 간단합니다. 반복할 작업 내용이 있는 코드를 복사하고 원하는 만큼 붙여넣기하면 됩니다. 하지만 100번, 1000번 또는 무한하게 반복 작업하고 싶을 때 코드를 계속 붙여넣기 하는 것은 무리입니다. 이럴 때 반복문을 사용하면 매우 편리합니다. 예를 들어 다음 코드는 출력을 100번 반복합니다.

for i in range(100) :
    print("출력")
    
## for 반복문: 리스트와 함께 사용하기

for 반복문의 기본 형태는 다음과 같습니다.

for 반복자 in 반복할 수 있는 것:
    코드
    
반복할 수 있는 것에는 문자열, 리스트, 딕셔너리, 범위 등이 있습니다.

다음은 for 반복문과 리스트를 조합해서 사용하는 예시코드입니다.

for_list.py
```python
# 리스트를 선언합니다.
array = [273, 32, 103, 57, 52]

# 리스트에 반복문을 적용합니다.
for element in array:
    # 출력합니다.
    print(element)
```

for 반복문은 리스트에 있는 요소 하나하나가 element라는 변소에 들어가며, 차례차례 반복하게 됩니다. print() 함수로 element를 출력하므로 리스트의 요소를 차례차례 출력하게 되는 것입니다.

# 딕셔너리와 반복문

리스트가 인덱스를 기반으로 값을 저장하는 것이라면 딕셔너리는 키를 기반으로 값을 저장하는 것이라고 할 수 있습니다. 

## 딕셔너리 선언하기

딕셔너리는 중괄호{}로 선언하며, '키: 값' 형태를 쉼표(,)로 연결해서 만듭니다. 키는 문자열, 숫자, 불 등으로 선언할 수 있습니다. 하지만 일반적으로는 문자열로 사용하는 경우가 많습니다.

다음은 딕셔너리를 생성하는 실습 코드입니다.
```python
dict_a = {
    "name" : "어벤저스 엔드게임",
    "type" : "히어로 무비"
    }
```

## 딕셔너리의 요소에 접근하기

바로 앞에 선언한 딕셔너리를 출력하면
```python
dict_a
{'name': '어벤져스 엔드게임', 'type': '히어로 무비'}
```
특정 키 값만 따로 출력할 수도 있습니다. 딕셔너리의 요소에 접근할 때는 리스트처럼 딕셔너리 뒤에 대괄호[]를 입력하고 내부에 인덱스처럼 키를 입력합니다.
주의해야 할 점은 딕셔너리를 선언할 때는 중괄호를 요소에 접근 할 때는 대괄호를 입력하고 내부에 인덱스처럼 키를 입력한다는 것입니다.
```python
dict_a["name"]
'어벤져스 엔드게임'
dict_a["type"]
'히어로 무비'
```

딕셔너리 내부의 값에 문자열, 숫자, 불 등의 다양한 자료를 넣을 수도 있습니다. 리스트와 딕셔너리도 하나의 자료이므로, 리스트와 딕셔너리를 값으로 넣을 수도 있습니다.
```python
dict_b = {
    "director": ["안소니 루소", "조 루소"],
    "cast": ["아이언맨", "타노스", "토르", "닥터스트레인지", "헐크"]
    }
```

다음은 딕셔너리의 요소에 접근하는 예시코드입니다.

dict01.py
```python
# 딕셔너리를 선언합니다.
dictionary = {
    "name": "7D 건조 망고",
    "type": "당절임",
    "ingredient": ["망고", "설탕", "메타중아황산나트륨", "치자황색소"],
    "origin": "필리핀"
}

# 출력합니다.
print("name:", dictionary["name"])
print("type:", dictionary["type"])
print("ingredient:", dictionary["ingredient"])
print("origin:", dictionary["origin"])
print()

# 값을 변경합니다.
dictionary["name"] = "8D 건조 망고"
print("name:", dictionary["name"])
```

## 딕셔너리의 문자열 키와 관련된 실수

딕셔너리를 만들 때 다음과 같이 입력 실수를 하는 경우가 꽤 많습니다. 이러한 코드를 실행하면 NameError라는 오류가 발생합니다.
```python
dict_key = {
    name: "7D 건조 망고",
    type: "당절임"
    }
```    
name 이라는 이름이 정의되지 않았다는 오류입니다. 파이썬은 딕셔너리의 키에 단순한 식별자를 입력하면 이를 변수로 인식합니다. 오류 자체를 해결하고 싶다면 name이라는 이름을 변수로 만들어주면 됩니다.

## 딕셔너리에 값 추가하기/제거하기

딕셔너리에 값을 추가할 때는 키를 기반으로 값을 입력하면 됩니다.

딕셔너리[새로운 키] = 새로운 값

딕셔너리 요소를 제거하고 싶을 때는 del 키워드를 사용하여 특정 키를 지정하면 해당 요소가 제거됩니다.

del 딕셔너리이름[제거하고 싶은 키]

아무것도 없는 딕셔너리에 요소를 추가하는 예시 코드입니다.

dict02.py
```python 
# 딕셔너리를 선언합니다.
dictionary = {}

# 요소추가 전에 내용을 출력해 봅니다.
print("요소 추가 이전:", dictionary)

# 딕셔너리에 요소를 추가합니다.
dictionary["name"] = "새로운 이름"
dictionary["head"] = "새로운 정신"
dictionary["body"] = "새로운 몸"

# 출력합니다.
print("요소 추가 이후:", dictionary)
```

다음은 두 개의 요소를 가진 딕셔너리를 선언하고, 이 두 요소를 제거한 후 내용을 출력하는 실습코드입니다.

dict03.py
```python
# 딕셔너리를 선언합니다.
dictionary = {
    "name": "7D 건조 망고",
    "type": "당절임"
}

# 요소 제거 전에 내용을 출력해 봅니다.
print("요소 제거 이전:", dictionary)

# 딕셔너리의 요소를 제거합니다.
del dictionary["name"]
del dictionary["type"]

# 요소 제거 후에 내용을 출력해 봅니다.
print("요소 제거 이후:", dictionary)
```

## keyError 예외

리스트의 길이를 넘는 인덱스에 접근하면 IndexError가 발생했습니다. 딕셔너리도 존재하지 않는 키에 접근하면 마찬가지로 KeyError가 발생합니다.

dictionary = {}
dictionary["Key"]

## 딕셔너리 내부에 키가 있는 지 확인하기

딕셔너리에 존재하지 않는 키에 접근하면 KeyError가 발생합니다. 그래서 존재하는 키인지, 존재하지 않는 키인지 확인할 수 있는 방법이 필요합니다.

## in 키워드

리스트 내부에 값이 있는지 없는지 확인할 때 in 키워드를 사용했던 것처럼 딕셔너리 내부에 키가 있는지 없는지 확인할 때도 in 키워드를 사용합니다.

다음은 사용자로부터 접근하고자 하는 키를 입력받은 후, 존재하는 경우에만 접근해서 값을 출력합니다.

key_in.py
```python
# 딕셔너리를 선언합니다.
dictionary = {
    "name": "7D 건조 광고",
    "type": "당절임",
    "ingredient": ["망고", "설탕"],
    "origin": "필리핀"
}

# 사용자로부터 입력을 받습니다.
key = input("> 접근하고자 하는 키:")

# 출력합니다.
if key in dictionary:
    print(dictionary[key])
else:
    print("존재하지 않는 키에 접근하고 있습니다.")
```

## get() 함수

존재하지 않는 키에 접근하는 상황에 대한 두 번째 대처 방법으로는 딕셔너리의 get() 함수를 사용하는 방법이 있습니다. get() 함수는 딕셔너리의 키로 값을 추출하는 기능으로 딕셔너리[키]를 입력할 때와 같은 기능을 수행하지만, 존재하지 않는 키에 접근할 경우 KeyError를 발생시키지 않고 None을 출력합니다.

다음은 키가 존재하지 않을 때 None을 출력하는지 확인하는 실습 코드입니다.

get01.py
```python
# 딕셔너리를 선언합니다.
dictionary = {
    "name": "7D 건조 광고",
    "type": "당절임",
    "ingredient": ["망고", "설탕"],
    "origin": "필리핀"
}

# 존재하지 않는 키에 접근해봅니다.
value = dictionary.get("존재하지 않는 키")
print("값:", value)

# None 확인 방법
if value == None:
    print("존재하지 않는 키에 접근했었습니다.")
```

## for 반복문 : 딕셔너리와 함께 사용하기

for 반복문과 딕셔너리를 조합해서 사용한다면 다음과 같은 형태가 됩니다. 여기서 주의할 점은 딕셔너리 내부에 있는 키가 변수에 들어간다는 것입니다.

for 키 변수 in 딕셔너리:
    코드

for 반복문과 딕셔너리를 실습하는 예제 코드입니다.

for_dict.py
```python
# 딕셔너리를 선언합니다.
dictionary = {
    "name": "7D 건조 망고",
    "type": "당절임",
    "ingredient": ["망고", "설탕"],
    "origin": "필리핀"
}

# for 반복문을 사용합니다.
for key in dictionary:
    # 출력합니다
    print(key, ":", dictionary[key])
```

# 반복문과 while 반복문

지금까지 리스트와 딕셔너리에 대해 알아보고 for 반복문에서 활용하는 방법도 배웠습니다. 추가로 for 반복문과 함께 많이 사용되는 자료형 중에 범위 range가 있습니다. 특정한 횟수만큼 반복해서 돌리고 싶을 때는 for 반복문과 범위를 조합해서 사용합니다.

## 범위

리스트, 딕셔너리 외에 for 반복문과 함께 많이 사용되는 범위 자료형의 사용법에 대해 알아보겠습니다.

1. 매개변수에 숫자를 한 개 넣는 방법

0부터 A-1까지의 정수로 범위를 만듭니다.

range(A) A는 숫자

2. 매개변수에 숫자를 두 개 넣는 방법

A부터 B-1까지의 정수로 범위를 만듭니다.

range(A, B) A와 B는 숫자

3. 매개변수에 숫자를 세 개 넣는 방법

A부터 B-1까지의 정수로 범위를 만드는데, 앞 뒤의 숫자가 C만큼의 차이를 가집니다.

range(A, B, C) A, B, C 는 숫자

list() 함수를 이용해 범위를 리스트로 변경하면 범위 내부에 어떤 값이 들어 있는지 확인할 수 있습니다.

## range() 함수의 매개변수에는 반드시 정수가 와야합니다.

range() 함수의 매개변수로는 반드시 정수를 입력해야 하기 때문에 int() 함수로 실수를 정수로 바꾸거나 정수 나누기 연산자를 사용합니다.

## for 반복문 : 범위와 함께 사용하기

for 숫자 변수 in 범위:
    코드
    
다음은 for 반복문과 범위를 사용한 예시코드입니다.

for_range.py
```python
# for 반복문과 범위를 함께 조합해서 사용합니다.
for i in range(5):
    print(str(i) + "= 반복 변수")
print()

for i in range(5, 10):
    print(str(i) + "= 반복 변수")
print()

for i in range(0, 10, 3):
    print(str(i) + "= 반복 변수")
print()
```

## for 반복문 : 리스트와 범위 조합하기

리스트와 반복문을 조합해서 사용할 때 반복을 적용하다 보면 "몇 번째 반복일까?"를 알아야 하는 경우가 있습니다.
다음은 리스트와 범위를 조합해서 "몇 번째인지 알아내는 방법"을 알아내는 예제 코드입니다.

list_range01.py
```python
# 리스트를 선언합니다.
array = [273, 32, 103, 57, 52]

# 리스트에 반복문을 적용합니다.
for i in range(len(array)):
    # 출력합니다.
    print("{}번째 반복: {}".format(i, array[i]))
```

## for 반복문 : 반대로 반복하기

방금 살펴본 반복문은 작은 숫자에서 큰 숫자 순서로 올라갔습니다. 그런데 프로그래밍을 하다 보면 큰 숫자에서 작은 숫자로 반복문을 적용해야 하는 경우도 있습니다. 이러한 반복문을 역반복문이라고 부르기도 합니다. 크게 두 가지 방법을 사용해서 만듭니다.

다음은 range() 함수의 매개변수를 세 개 사용해서 역반복문을 만드는 예시코드입니다.

reversed_for01.py
```python
# 역반복문
for i in range(4, 0 - 1, -1):
    # 출력합니다.
    print("현재 반복 변수: {}".format(i))
```

두 번째 방법으로 reversed() 함수를 사용해서 역반복문을 만드는 예시코드입니다.

reversed_for02.py
```python
# 역반복문
for i in reversed(range(5)):
    # 출력합니다.
    print("현재 반복 변수: {}".format(i))
```

## while 반복문

리스트 또는 딕셔너리 내부의 요소를 모두 순회하는 경우, 즉 특정 횟수만큼 반복하는 경우에는 for 반복문을 사용합니다. 그런데 파이썬에서는 for 반복문 이외에도 범용적으로 사용할 수 있는 while반복문이 있습니다. 기본적인 형태는 다음과 같습니다.

while 불 표현식:
    문장

if 조건문과 굉장히 비슷한 형식인데, <불 표현식>이 참인 동안 문장을 계속 반복합니다.

## while 반복문: for 반복문처럼 사용하기

다음은 while 반복문의 기본적인 사용 방법을 알아보는 예시코드를 알아보겠습니다.

while_as_for.py
```python
# 반복 변수를 기반으로 반복하기
i = 0
while i < 10:
    print("{}번 째 반복입니다.".format(i))
    i += 1
```

for 반복문으로는 무한 반복을 구현할 수 없습니다. 그리고 while 반복문에서 가장 중요한 키워드는 '조건'입니다. 조건을 활용해서 반복을 사용해야 한다면 while 반복문을 사용하는 것이 좋습니다. 조건이 중요한 경우에 대해 살펴보겠습니다.

## while 반복문: 상태를 기반으로 반복하기

리스트의 remove() 함수는 리스트 내부에서 해당하는 값을 하나만 제거할 수 있었습니다. while 반복문을 활용하면 여러 개를 제거 할 수 있습니다. while 반복문의 조건을 '리스트 내부에 요소가 있는동안' 으로 지정합니다.

while_with_condition.py
```python
# 변수를 선언합니다.
list_test = [1, 2, 1, 2]
value = 2

# list_test 내부에 value가 있다면 반복
while value in list_test:
    list_test.remove(value)

# 출력합니다.
print(list_test)
```

## while 반복문: 시간을 기반으로 반복하기

시간을 기반으로 반복하는 예를 살펴보겠습니다. 시간을 기반으로 반복하려면 유닉스 타임이라는 개념을 알아야 합니다. 유닉스 타임 Unix Time 이란 세계 표준시로, 1970년 1월 1일 0시 0분 0초를 기준으로 몇 초가 지났는지를 정수로 나타낸 것을 말합니다. 파이썬에서 유닉스 타임을 구할 때는 다음과 같은 코드를 사용합니다.

먼저 시간과 관련된 기능을 가져옵니다.
```python
import time
```

그런 다음 유닉스 타임을 구합니다.
```python
time.time()
```
이러한 유닉스 타임과 while 반복문을 조합하면 특정 시간 동안 프로그램을 정지시킬 수 있습니다.

유닉스 타임을 설정해서 5초 동안 반복하는 프로그램의 예시코드입니다.

while_with_time.py
```
# 시간과 관련된 기능을 추가합니다.
import time

# 변수를 선언합니다.
number = 0

# 5초 동안 반복합니다.
target_tick = time.time() + 5
while time.time() < target_tick:
    number += 1

# 출력합니다.
print("5초 동안 {}번 반복했습니다.".format(number))
```

## while 반복문: break 키워드/ continue 키워드

반복문 내부에서만 사용할 수 있는 break와 continue라는 특수한 키워드가 있습니다. break 키워드는 반복문을 벗어날 때 사용합니다. 일반적으로 무한 반복문을 만들고, 내부의 반복을 벗어날 때 사용합니다.

break.py
```python
# 변수를 선언합니다.
i = 0

# 무한 반복합니다.
while True:
    # 몇 번째 반복인지 출력합니다.
    print("{}번 째 반복문입니다.".format(i))
    i += 1
    # 반복을 종료합니다.
    input_text = input("> 종료하시겠습니까?(y/n): ")
    if input_text in ["y", "Y"]:
        print("반복을 종료합니다.")
        break
```

continue 키워드는 현재 반복을 생략하고, 다음 반복으로 넘어갈 때 사용하는 키워드입니다.

break01.py
```python
# 변수를 선언합니다.
numbers = [5, 15, 6, 20, 7, 25]

# 반복을 돌립니다.
for number in numbers:
    # number가 10보다 작으면 다음 반복으로 넘어갑니다.
    if number < 10:
        continue
    # 출력합니다.
    print(number)
```

ie else 구문을 사용해도 똑같지만 continue 키워드를 사용하면 이후 처리의 들여쓰기를 하나 줄일 수 있습니다.

# 문자열, 리스트, 딕셔너리와 관련된 기본 함수

이번 절의 내용은 파이썬만의 고유한 기능들이라고 할 수 있을 정도로, 다른 언어에서는 보기 힘든 형태의 기능들입니다.

1. 리스트에 적용할 수 있는 기본 함수: min(), max(), sum()
2. 리스트 뒤집기 : reversed()
3. 현재 인덱스가 몇 번째인지 확인하기 : enumerate()
4. 딕셔너리로 쉽게 반복문 작성하기 : items()
5. 리스트 안에 for문 사용하기 : 리스트 내포

## 리스트에 적용할 수 있는 기본 함수: min(), max(), sum()

min(), max(), sum() 함수들은 리스트를 매개변수로 넣어 사용하는 매우 기본적인 함수입니다.

min() : 리스트 내부에서 최솟값을 찾습니다.
max() : 리스트 내부에서 최댓값을 찾습니다.
sum() : 리스트 내부에서 값을 모두 더합니다.

```python
numbers = [103, 52, 273, 32, 77]
min(numbers)
32
max(numbers)
273
sum(numbers)
537
```

## reversed() 함수로 리스트 뒤집기

리스트에서 요소의 순서를 뒤집고 싶을 때는 reversed() 함수를 사용합니다. reversed() 함수의 매개변수에 리스트를 넣으면 리스트를 뒤집을 수 있습니다.

reversed.py
```python
# 리스트를 선언하고 뒤집습니다.
list_a = [1, 2, 3, 4, 5]
list_reversed = reversed(list_a)

# 출력합니다.
print("# reversed() 함수")
print("reversed([1, 2, 3, 4, 5]):", list_reversed)
print("list(reversed([1, 2, 3, 4, 5]):", list(list_reversed))
print()

# 반복문을 적용해봅니다.
print("# reversed() 함수와 반복문")
print("for i in reversed([1, 2, 3, 4, 5]):")
for i in reversed(list_a):
    print("-", i)
```

```python
temp = reversed([1, 2, 3, 4, 5, 6])

for i in temp:
    print("첫 번째 반복문: {}".format(i))
    
for i in temp:
    print("두 번째 반복문: {}".format(i))
```
코드를 실행하면 "첫 번째 반복문"부분믄 실행됩니다. "두 번째 반복문"부분은 전혀 출력되지 않습니다.
reversed() 함수의 결과는 제너레이터입니다. 제너레이터는 파이썬의 특별한 기능으로, 일단 reversed() 함수와 반복문을 조합할 때는 함수의 결과를 여러 번 활용하지 않고 for 구문 내부에 reversed() 함수를 곧바로 넣어서 사용합니다.

## enumerate() 함수와 반복문 조합하기

enumerate() 함수와 반복문을 조합해서 리스트의 요소를 반복할 때 현재 인덱스가 몇 번째 인지 확인하는 프로그램의 예시코드입니다.

enumerate.py
```python
# 변수를 선언합니다.
example_list = ['요소A', '요소B', '요소C']

#  그냥 출력합니다.
print("# 단순 출력")
print(example_list)
print()

# enumerate() 함수를 적용해 출력합니다.
print("# enumerate() 함수 적용 출력")
print(enumerate(example_list))
print()

# list() 함수로 강제 변환해 출력합니다.
print("# list() 함수로 강제 변환 출력")
print(list(enumerate(example_list)))
print()

# for 반복문과 enumerate() 함수 조합해서 사용하기
print("# 반복문과 조합하기")
for i, value in enumerate(example_list):
    print("{}번 째 요소는 {}입니다.".format(i, value))
```

## 딕셔너리의 items() 함수와 반복문 조합하기

enumerate() 함수와 반복문을 조합해서 for i, value in enumerate(리스트) 형태로 반복문을 작성할 수 있었던 것처럼 딕셔너리는 item() 함수와 함께 사용하면 키와 값을 조합해서 쉽게 반복문을 작성할 수 있습니다.

딕셔너리의 items()함수와 반복문
items.py
```python
# 변수를 선언합니다.
example_dictionary = {
    "키A": "값A",
    "키B": "값B",
    "키C": "값C",
}

# 딕셔너리의 items() 함수 결과 출력하기
print("# 딕셔너리의 items() 함수")
print("items():", example_dictionary.items())
print()

# for 반복문과 items() 함수 조합해서 사용하기
print("# 딕셔너리의 items() 함수와 반복문 조합하기")


for key, element in example_dictionary.items():
    print("dictionary[{}] = {}".format(key, element))
```

## 리스트 내포

프로그램을 만들 때는 반복문을 사용해 리스트를 재조합하는 경우가 많습니다.

반복문을 사용한 리스트 생성하는 프로그램의 예시코드입니다.

for_list01.py
```python
# 변수를 선언합니다.
array = []

# 반복문을 적용합니다.
for i in range(0, 20, 2):
    array.append(i * i)

# 출력합니다
print(array)
```

리스트 안에 for문을 사용하는 리스트 내포 list comprehensions을 사용한 프로그램의 예시코드입니다.

list_in.py
```python
# 리스트를 선언합니다.
array = [i * i for i in range(0, 20, 2)]

# 출력합니다.
print(array)
```

뒤에 if 구문을 넣어 조건을 조합할 수도 있습니다. 다음은 조건을 활용한 리스트 내포 프로그램의 예시코드입니다.

array_comprehensions.py
```python
# 리스트를 선언합니다.
array = ["사과", "자두", "초콜릿", "바나나", "체리"]
output = [fruit for fruit in array if fruit != "초콜릿"]

# 출력합니다.
print(output)
```
# 함수

## 함수의 기본

함수는 한마디로 '코드의 집합'입니다. 함수를 생성하는 기본 형태는  다음과 같습니다.

def 함수 이름():
    문장
    
다음 코드는 세 문장을 포함하는 print_3_times 함수를 만든 후 호출하여 실행하는 간단한 예제코드입니다.

fun_basic.py
```python
def print_3_times():
    print("안녕하세요")
    print("안녕하세요")
    print("안녕하세요")


print_3_times()
```

## 함수에 매개변수 만들기

매개변수는 함수를 생성할 때 괄호 내부에 식별자를 입력해서 만듭니다.

def 함수 이름(매개변수, 매개변수2, ...):
    문장
    
다음은 함수에 매개변수를 만드는 예시코드입니다.

param_basic.py
```python
def print_n_times(value, n):
    for i in range(n):
        print(value)
       
       
print_n_times("안녕하세요", 5)
```

## 매개변수와 관련된 TypeError

함수를 생성할 때 매개변수를 만들었는데, 함수를 호출할 때 매개변수를 넣지 않거나 더 많이 넣으면 TypeError를 발생시킵니다.
그러므로 함수를 호출할 때는 함수를 선언할 때와 같은 개수의 매개변수를 입력해야 합니다.

## 가변 매개변수

print() 함수와 같이 매개변수를 원하는 만큼 받을 수 있는 함수를 가변 매개변수라고 부르는데, 이는 매개변수가 변할 수 있다는 의미입니다.

가변 매개변수 함수는 다음과 같은 구조로 만듭니다.

def 함수 이름(매개 변수, 매개변수, ... *가변 매개변수):
    문장
    
가변 매개변수를 사용할 때는 다음과 같은 제약이 있습니다.

1. 가변 매개변수 뒤에는 일반 매개변수가 올 수 없습니다.
2. 가변 매개변수는 하나만 사용할 수 있습니다.

제약이 약간 어렵게 느껴질 수 있는데, 이러한 제약이 없으면 가변 매개변수가 어디부터 어디까지인지 알 수 없기 때문에 만들어진 규칙입니다.

다음은 가변 매개변수 함수를 이용한 프로그램의 예시코드입니다.

variable_param.py
```python
def print_n_times(n, *values):
    # n번 반복합니다.
    for i in range(n):
        # values는 리스트처럼 활용합니다.
        for value in values:
            print(value)
        # 단순한 줄바꿈
        print()


# 함수를 호출합니다.
print_n_times(3, "안녕하세요", "즐거운", "파이썬 프로그래밍")
```

## 기본 매개변수

매개변수=값 형태로 되어있는 것을 기본 매개변수라고 부르며, 매개변수를 입력하지 않았을 경우 매개변수에 들어가는 기본값입니다. 기본 매개변수도 다음과 같은 제약이 있습니다.

1. 기본 매개변수 뒤에는 일반 매개변수가 올 수 없습니다.

다음은 기본 매개변수를 활용한 예시코드입니다.

default_param.py
```python
def print_n_times(value, n=2):
    # n번 반복합니다.
    for i in range(n):
        print(value)


# 함수를 호출합니다.
print_n_times("안녕하세요")
```

## 키워드 매개변수

### 기본 매개변수가 가변 매개변수보다 앞에 올 때

기본 매개변수가 가변 매개변수보다 앞에 올 때는 기본 매개변수의 의미가 사라집니다.
```python
def print_n_times(n=2, *values):
    # n번 반복합니다.
    for i in range(n):
        # values는 리스트처럼 활용합니다.
        for value in values:
            print(value)
        # 단순한 줄바꿈
        print()

# 함수를 호출합니다.
print_n_times("안녕하세요", "즐거운", "파이썬 프로그래밍")
```

매개변수가 순서대로 입력되므로 n에는 "안녕하세요"가 들어가고, values에는 ["즐거운", "파이썬 프로그래밍"]이 들어옵니다. 그런데 range()함수의 매개변수에는 숫자만 들어올 수 있으므로 TypeError가 발생합니다. 따라서 기본 매개변수는 가변 매개변수 앞에 써도 의미가 없습니다.

## 가변 매개변수가 기본 매개변수보다 앞에 올 때

```python
def print_n_times(*values, n=2):
    # n번 반복합니다.
    for i in range(n):
        # values는 리스트처럼 활용합니다.
        for value in values:
            print(value)
        # 단순한 줄바꿈
        print()

# 함수를 호출합니다.
print_n_times("안녕하세요", "즐거운", "파이썬 프로그래밍", 3)
```

다음과 같은 두 가지 예측을 할 수 있습니다.

1. ["안녕하세요", "즐거운", "파이썬 프로그래밍"] 을 세 번 출력합니다.
2. ["안녕하세요", "즐거운", "파이썬 프로그래밍", 3] 을 두 번 출력합니다.

코드를 실행하면 두 번째 예상대로 실행됩니다. 가변 매개변수가 우선되는 것입니다.

두 가지를 함께 사용할 수 있는 방법에 대비해서 키워드 매개변수가 있습니다.

## 키워드 매개변수

이전 코드에서 1. ["안녕하세요", "즐거운", "파이썬 프로그래밍"] 을 세 번 출력합니다.으로 출력하려면 다음과 같이 매개변수 이름을 직접적으로 지정해서 값을 입력합니다.
```python
def print_n_times(*values, n=2):
    # n번 반복합니다.
    for i in range(n):
        # values는 리스트처럼 활용합니다.
        for value in values:
            print(value)
        # 단순한 줄바꿈
        print()

# 함수를 호출합니다.
print_n_times("안녕하세요", "즐거운", "파이썬 프로그래밍", n=3)
```

## 기본 매개변수 중에서 필요한 값만 입력하기

키워드 매개변수는 기본 매개변수들로 구성된 함수에서도 많이 사용됩니다. 

param_examples.py
```python
def test(a, b=10, c=100):
    print(a + b + c)


# 1) 기본 형태
test(10, 20, 30)

# 2) 키워드 매개변수로 모든 매개변수를 지정한 상태
test(a=10, b=100, c=200)

# 3) 키워드 매개변수로 모든 매개변수를 마구잡이로 지정한 형태
test(c=10, a=100, b=200)

# 4) 키워드 매개변수로 일부 매개변수만 지정한 형태
test(10, c=200)
```

3번째 경우를 봤을 때 키워드를 지정해서 매개변수를 입력하는 경우에는 매개변수 순서를 원하는 대로 입력할 수 있습니다.
4번째 경우를 봤을 때 키워드 매개변수를 사용하면 필요한 매개변수에만 값을 전달할 수 있습니다.

즉 일반적으로 '일반 매개변수'는 필수로 순서에 맞게 입력합니다. '기본 매개변수'는 필요한 것만 키워드를 지정해서 입력하는 경우가 많습니다.

## 리턴

### 자료 없이 리턴하기

함수 내부에서는 return이라는 키워드를 사용할 수 있습니다. 이 키워드는 함수를 실행했던 위치로 돌아가라는 뜻으로, 함수가 끝나는 위치를 말합니다.

다음은 자료 없이 리턴하는 예시코드입니다.

return_only.py
```python
# 함수를 정의합니다.
def return_test():
    print("A 위치입니다.")
    return  # 리턴합니다.
    print("B 위치입니다.")


# 함수를 호출합니다.
return_test()
```
함수 내부에서 출력을 두 번 사용했는데, 중간에 return 키워드가 들어 있습니다. return 키워드는 함수를 실행했던 위치로 돌아가라는 의미와 함수를 여기서 끝내라는 의미를 가지고 있습니다. 따라서 return 키워드를 만나는 순간 함수가 종료됩니다. 결과적으로 "A 위치입니다"만 출력되고 프로그램이 종료됩니다.

### 자료와 함께 리턴하기

리턴 뒤에 자료를 입력하면 자료를 가지고 리턴합니다(돌아갑니다). 다음은 return 키워드 뒤에 100이라는 숫자를 입력한 코드입니다. 함수의 실행결과로 100이 출력되는 것을 확인할 수 있습니다.

다음은 자료와 함께 리턴하는 예시코드입니다.

return_with_data.py
```python
# 함수를 정의합니다.
def return_test():
    return 100


# 함수를 호출합니다.
value = return_test()
print(value)
```

### 아무것도 리턴하지 않기

다음은 아무것도 리턴하지 않는 프로그램의 예시코드입니다.

return_none.py
```python
# 함수를 정의합니다.
def return_test():
    return


# 함수를 호출합니다.
value = return_test()
print(value)
```

None을 출력합니다. None은 파이썬에서 '없다'라는 의미입니다.

## 기본적인 함수의 활용

리턴과 관련된 구문의 형식을 간단하게 살펴보았습니다. 일반적으로 함수는 다음과 같이 값을 만들어 리턴하는 형태로 많이 사용합니다.

def 함수(매개변수):
    변수 = 초깃값
    # 여러 가지 처리
    # 여러 가지 처리
    return 변수
   
   
다음은 함수를 활용하는 간단한 예제로 범위 내부의 정수를 모두 더하는 함수의 예시 코드입니다.

sum_all_basic.py
```python
# 함수를 선언합니다.
def sum_all(start, end):
    # 변수를 선언합니다.
    output = 0
    # 반복문을 돌려 숫자를 더합니다.
    for i in range(start, end + 1):
        output += i
    # 리턴합니다
    return output


# 함수를 호출합니다.
print("0 to 100:", sum_all(0, 100))
print("0 to 1000:", sum_all(0, 1000))
print("50 to 100:", sum_all(50, 100))
print("500 to 1000:", sum_all(500, 1000))
```
일반적으로 초깃값을 설정할 때는 연산을 해도 값에 아무런 변화를 주지 않는 값을 사용합니다. 예를 들면 덧셈식에서는 0입니다. 어떤 값에 0을 더하면 아무런 변화가 없습니다. 
기본 매개변수를 사용하면 함수를 조금 더 편리하게 사용할 수 있습니다. 위의 코드에서 매개변수에 기본값을 주면 다음과 같은 형태로 코드를 사용할 수 있습니다.

```python
# 함수를 선언합니다.
def sum_all(start=0, end=100, step=1):
    # 변수를 선언합니다.
    output = 0
    # 반복문을 돌려 숫자를 더합니다.
    for i in range(start, end+1, step):
        output += i
    # 리턴합니다.
    return output


print("A.", sum_all(0, 100, 10))
print("B.", sum_all(100))
print("C.", sum_all(end=100, step=2))
```

함수를 어떻게 잘 만들 것인지는 사실 코드를 많이 보는 방법밖에 없습니다. 이전에 언급했던 것처럼 자신이 나아갈 방향(웹 개발, 기계 학습)등이 있다면 관련된 라이브러리 코드를 많이 살펴보는 것이 좋습니다. 

# 함수의 활용

## 재귀 함수

팩토리얼 연산자를 배웁니다. 간단하게 정리하면 다음과 같은 연산입니다.

n! = n*(n-1)*(n-2)* ... * 1

이러한 팩토리얼을 구하는 방법은 두 가지로 구분할 수 있습니다.

1. 반복문으로 팩토리얼 구하기
2. 재귀 함수로 팩토리얼 구하기

## 반복문으로 팩토리얼 구하기

다음은 반복문으로 팩토리얼을 구하는 프로그램의 예시코드입니다.

factorial_for.py
```python
# 함수를 선언합니다.
def factorial(n):
    # 변수를 선언합니다.
    output = 1
    # 반복문을 돌려 숫자를 더합니다.
    for i in range(1, n+1):
        output *= i
    # 리턴합니다
    return output


# 함수를 호출합니다.
print("1!:", factorial(1))
print("2!:", factorial(2))
print("3!:", factorial(3))
print("4!:", factorial(4))
print("5!:", factorial(5))
```

## 재귀 함수로 팩토리얼 구하기

두 번째 방법은 재귀 함수를 사용하는 방법입니다. 재귀 recursion 이란 '자기 자신을 호출하는 것'을 의미합니다. 팩토리얼 연산은 이전에 언급했던 것처럼 다음과 같이 표현할 수 있지만

n! = n * (n - 1) * (n - 2) * ... 1

다음과 같이 표현할 수도 있습니다.

factorial(n) = n * factorial(n - 1) (n >= 1 일 때)
factorial(0) = 1

이와 같은 재귀 표현을 이용하여 factorial(4)를 구해 보겠습니다.

f(4) = 4 * f(3)
     = 4 * 3 * f(2)
     = 4 * 3 * 2 * f(1) * f(0)
     = 4 * 3 * 2 * 1 * 1
    
다음은 재귀 함수를 사용해 팩토리얼을 구하는 프로그램의 예시코드입니다.

factorial_recursion.py
```python
# 함수를 선언합니다.
def factorial(n):
    # n이 0이라면 1을 리턴
    if n == 0:
        return 1
    # n이 0이 아니라면 n * (n-1)을 리턴
    else:
        return n * factorial(n-1)


# 함수를 호출합니다.
print("1!:", factorial(1))
print("2!:", factorial(2))
print("3!:", factorial(3))
print("4!:", factorial(4))
print("5!:", factorial(5))
```

## 재귀 함수의 문제

재귀 함수는 상황에 따라서 같은 것을 기하급수적으로 많이 반복한다는 문제가 있습니다. 그래서 개발자 사이에서는 재귀 함수를 절대 사용하면 안 된다는 의견도 있습니다. 하지만 필요할 때 적재적소에 활용하면 코드를 쉽게 알아볼 수 있습니다. 재귀 함수로 인해 발생하는 문제를 알아보고, 이후에 이 문제를 해결할 수 있는 메모화 memoization 라는 기술을 알아보겠습니다.

재귀 함수를 하나 더 살펴보겠습니다. 바로 피보나치 수열입니다. 피보나치 수열은 '토끼는 어떠한 속도로 번식하는가' 연구와 '꽃들의 꽃잎 수'를 계산할 때 사용하는 수열입니다. 

다음은 재귀 함수로 피보나치 수열을 구현하는 프로그램의 예시코드입니다.

fibonacci_recursion01.py
```python
# 함수를 선언합니다.
def fibonacci(n):
    if n == 1:
        return 1
    if n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)


# 함수를 호출합니다.
print("fibonacci(1):", fibonacci(1))
print("fibonacci(2):", fibonacci(2))
print("fibonacci(3):", fibonacci(3))
print("fibonacci(4):", fibonacci(4))
print("fibonacci(5):", fibonacci(5))

print("fibonacci(35):", fibonacci(35))
```

fibonacci(35)를 입력해서 35번째 피보나치 수를 구했을 때 4초 정도 걸리고 fibonacci(50)을 만들어서 50번째 피보나치 숫자를 구할 때는 1시간이 걸립니다.

다음은 재귀함수의 연산의 수를 구하는 코드로 변경해보겠습니다.

```python
# 변수를 선언합니다.
counter = 0

# 함수를 선언합니다.


def fibonacci(n):
    # 어떤 피보나치 수를 구하는지 출력합니다.
    print("fibonacci({})를 구합니다.".format(n))
    global counter
    counter += 1
    # 피보나치 수를 구합니다.
    if n == 1:
        return 1
    if n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)


# 함수를 호출합니다.
fibonacci(10)
print("---")
print("fibonacci(10) 계산에 활용된 덧셈 횟수는 {}번입니다".format(counter))
```
코드를 실행해보면 같은 것을 여러 번 연산한다는 것을 확인할 수 있습니다. 이렇게 덧셈 횟수가 기하급수적으로 늘어나는 이유는 트리 내부에 있는 각각의 노드 값을 계산하려면 덧셈을 한 번씩 해야합니다. 그런데 노드가 한 번에 두 개씩 달려 있습니다. 한 번 구한 값은 그것으로 계산이 끝나면 좋겠지만, 현재 코드의 재귀 함수는 한 번 구했던 값이라도 처음부터 다시 계산해야 합니다. 그래서 계산 횟수가 기하급수적으로 늘어나는 것입니다.

## UnboundLocalError에 대한 처리

파이썬은 함수 내부에서 함수 외부에 있는 변수를 참조하지 못합니다. 변수에 접근하는 것을 참조 reference라고 부릅니다. 함수 내부에서 함수 외부에 있는 변수라는 것을 설명하려면 다음과 같은 구문을 사용합니다.

global 변수 이름

global 키워드는 파이썬 프로그래밍 언어에만 있는 특이한 구조입니다.

## 메모화

재귀 함수의 이러한 문제 때문에 재귀 함수를 사용하지 말라는 개발자도 있습니다. 하지만 필요한 경우에 활용하면 코드가 간결해지며 읽기도 쉬워집니다.
현재 문제는 같은 값을 구하는 연산을 반복하고 있기 때문에 발생하는 것입니다. 따라서 같은 값을 한 번만 계산하도록 코드를 수정하면 됩니다.

다음은 메모화를 적용한 프로그램의 예시코드입니다.

fibonacci_memo.py
```python
# 메모 변수를 만듭니다.
dictionary = {
    1: 1,
    2: 1
}

# 함수를 선언합니다.


def fibonacci(n):
    if n in dictionary:
        # 메모가 되어 있으면 메모된 값을 리턴
        return dictionary[n]
    else:
        # 메모가 되어 있지 않으면 값을 구함
        output = fibonacci(n - 1) + fibonacci(n - 2)
        dictionary[n] = output
        return output


# 함수를 호출합니다.
print("fibonacci(10):", fibonacci(10))
print("fibonacci(20):", fibonacci(20))
print("fibonacci(30):", fibonacci(30))
print("fibonacci(40):", fibonacci(40))
print("fibonacci(50):", fibonacci(50))
```

딕셔너리를 사용해서 한 번 계산한 값을 저장합니다. 이를 메모 memo한다고 표현합니다. 딕셔너리에 값이 메모되어 있으면 처리를 수행하지 않고 곧바로 메모된 값을 돌려주면서 코드의 속도를 빠르게 만드는 것입니다.
이전에는 fibonacci(50)을 계산하는 데 한참 걸렸지만, 메모화를 사용하면 실행 후 곧바로 결과를 출력할 정도로 속도가 빨라집니다. 재귀 함수와 함께 많이 사용되는 기술이므로 기억하는 게 좋습니다.

## 조기 리턴

과거에는 프로그래밍을 할 때 변수는 반드시 앞 쪽에 몰아서 선언하고, 리턴은 반드시 뒤쪽에서 해야한다는 비공식적인 규칙이 있었습니다. 하지만 요즘에는 필요할 때 하면 된다는 인식이 널리 퍼졌습니다. 

다음은 조기리턴을 사용하지 않은 프로그램의 예시코드입니다.

```python
def fibonacci(n):
    if n in dictionary:
        # 메모되어 있으면 메모된 값을 리턴
        return dictionary[n]
    else:
        # 메모되어 있지 않으면 값을 구함
        output = dictionary(n - 1) + dictionary(n - 2)
        dictionary[n] = output
        return output
```
다음은 조기리턴을 적용한 프로그램의 예시코드입니다. 
```python
def fibonacci(n):
    if n in dictionary:
        # 메모되어 있으면 메모된 값을 리턴
        return dictionary[n]
    # 메모되어 있지 않으면 값을 구함
    output = dictionary(n - 1) + dictionary(n - 2)
    dictionary[n] = output
    return output
```

들여쓰기 단계가 줄기 때문에 코드를 더 쉽게 읽을 수 있습니다. 이렇게 흐름 중간에 return 키워드를 사용하는 것을 조기 리턴 early return이라고 부릅니다.

# 함수 고급

반복문 때와 마찬가지로, 지금까지 살펴보았던 함수 관련 내용은 모든 프로그램이 언어에서 거의 비슷한 형태로 사용할 수 있는 내용입니다. 그런데 파이썬은 함수를 조금 더 편리하게 사용할 수 있게 다양한 기능들을 제공해 줍니다. 그 대표적인 것이 튜플 tuple과 람다 lambda입니다.

1. 튜플 : 함수와 함께 많이 사용되는 리스트와 비슷한 자료형으로, 리스트와 다른 점은 한번 결정된 요소는 바꿀 수 없다는 것
2. 람다 : 매개변수로 함수를 전달하기 위해 함수 구문을 작성하는 것이 번거롭고, 코드 공간 낭비라는 생각이 들 때 함수를 간단하고 쉽게 선언하는 방법

## 튜플 

튜플 tuple은 리스트와 비슷한 자료형입니다. 리스트와 다른 점은 한번 결정된 요소를 바꿀 수 없다는 것입니다. 일반적으로 튜플은 함수와 함께 많이 사용되는 자료형입니다. 튜플은 다음과 같은 방법으로 생성합니다.

(데이터, 데이터, 데이터, ..)

다음은 튜플을 선언해 생성한 후 각 요소를 출력하는 예시코드입니다.
```python
tuple_test = (10, 20, 30)

tuple_test[0]
10
tuple_test[1]
20
tuple_test[2]
30
```

여기까지만 살펴보면 튜플과 리스트에 차이가 없습니다. 하지만 요소를 변경할 때 차이가 있습니다. 0번째 요소에 1을 넣으려고 하니 에러를 발생합니다. 튜플은 내부 요소 변경이 불가능합니다

## 괄호 없는 튜플

파이썬의 리스트와 튜플은 특이한 형태의 할당 구문으로 사용할 수 있습니다. 

다음은 리스트와 튜플의 특이한 사용 프로그램의 예시코드입니다.

tuple_basic.py
```python
# 리스트와 튜플의 특이한 사용
[a, b] = [10, 20]
(c, d) = (10, 20)

# 출력합니다.
print("a:", a)
print("b:", b)
print("c:", c)
print("d:", d)
```

리스트와 튜플을 사용하면 이와 같은 형태로 변수를 선언하고 할당할 수 있습니다. 그런데 튜플은 정말 특이한 성질이 있습니다. 괄호를 생략해도 튜플로 인식할 수 있는 경우는 괄호를 생략해도 됩니다. 
다음은 괄호가 없는 튜플을 이용한 프로그램의 예시코드입니다.

tuple_use01.py
```python
# 괄호가 없는 튜플
tuple_test = 10, 20, 30, 40
print("# 괄호가 없는 튜플의 값과 자료형 출력")
print("tuple_test:", tuple_test)
print("type(tuple_test):", type(tuple_test))
print()

# 괄호가 없는 튜플 활용
a, b, c = 10, 20, 30
print("# 괄호가 없는 튜플을 활용한 할당")
print("a:", a)
print("b:", b)
print("c:", c)
```
편리함으로 인해 자주 사용되는 형태입니다. 이러한 특이한 구문의 편리함은 다음 코드로 확인할 수 있습니다.
다음은 변수의 값을 교환하는 프로그램의 예시코드입니다.

tuple_use02.py
```python
a, b = 10, 20

print("# 교환 전 값")
print("a:", a)
print("b:", b)
print()

# 값을 교환합니다.
a, b = b, a

print("# 교환 후 값")
print("a:", a)
print("b:", b)
print()
```

a, b = b, a 라는 코드만으로 값이 바뀝니다.

## 튜플과 함수

튜플은 함수의 리턴에 많이 사용합니다. 함수의 리턴에 튜플을 사용하면 여러 개의 값을 리턴하고 할당할 수 있기 때문입니다. 다음 코드의 실행결과를 예측해 보세요. 튜플을 사용해 할당할 수 있다는 것을 깨달으면 쉽게 이해할 수 있는 코드입니다.

tuple_return.py
```python
# 함수를 선언합니다.
def test():
    return(10, 20)


# 여러 개의 값을 리턴받습니다.
a, b = test()

# 출력합니다.
print("a:", a)
print("b:", b)
```

튜플도 리스트처럼 + 와 * 연산자 등을 활용할 수 있습니다. 하지만 그런 것들을 리스트로 작성하는 것과 큰 차이가 없어서 튜플을 사용하는 경우는 거의 없습니다. 이번 절에서 살펴본 것처럼 괄호 없이 여러 값을 활당하는 것은 튜플로만 할 수 있는 일입니다.

## 람다

요즘 프로그래밍 언어에서는 함수라는 '기능'을 매개변수로 전달하는 코드를 많이 사용합니다. 그리고 이런 코드를 조금 더 효율적으로 작성할 수 있도록 파이썬은 람다 lambda 라는 기능을 제공합니다.

### 함수의 매개변수로 함수 전달하기

함수를 매개변수로 전달하는 것부터 람다까지 알아보겠습니다.

다음은 함수의 매개변수로 함수를 전달하는 프로그램의 예시코드입니다.

func_as_param.py
```python
# 매개변수로 받은 함수를 10번 호출하는 함수
def call_10_times(func):
    for i in range(10):
        func()

# 간단한 출력하는 함수


def print_hello():
    print("안녕하세요")


# 조합하기
call_10_times(print_hello)
```

프로그램을 실행하면 print_hello() 함수를 10번 실행합니다. 따라서 "안녕하세요"라는 문자열을 10번 출력합니다.

## filter() 함수와 map() 함수

함수를 매개변수로 전달하는 대표적인 표준 함수로 map() 함수와 filter() 함수가 있습니다. *파이썬이 표준으로 제공하는 함수를 '내장 함수' 또는 '표준 함수'라고 합니다.

map() 함수는 리스트의 요소를 함수에 넣고 리턴된 값으로 새로운 리스트를 구성해 주는 함수입니다.

map(함수, 리스트)

filter() 함수는 리스트의 요소를 함수에 넣고 리턴된 값이 True 인 것으로, 새로운 리스트를 구성해 주는 함수입니다.

filter(함수, 리스트)

다음은 map() 함수와 filter() 함수를 사용하는 프로그램의 예시코드입니다.

call_with_func.py
```python
# 함수를 선언합니다.
def power(item):
    return item * item


def under_3(item):
    return item < 3


# 변수를 선언합니다.
list_input_a = [1, 2, 3, 4, 5]

# map() 함수를 사용합니다.
output_a = map(power, list_input_a)
print("# map() 함수의 실행결과")
print("map(power, list_input_a:", output_a)
print("map(power, list_input_a:", list(output_a))

# filter() 함수를 사용합니다.
output_b = filter(under_3, list_input_a)
print("# filter() 함수의 실행결과")
print("filter(under_3, list_input_a):", output_b)
print("filter(under_3, list_input_a):", list(output_b))
```

## 람다의 개념

매개변수로 함수를 전달하기 위해 함수 구문을 작성하는 것도 번거롭고, 코드 공간 낭비라는 생각이 들 수 있습니다. 많은 개발자들이 이러한 생각을 했고, 그래서 람다 lambda 라는 개념을 생각했습니다. 람다는 '간단한 함수를 쉽게 선언하는 방법'입니다. 다음과 같은 형태로 만듭니다.

lambda 매개변수: 리턴값

이전 코드를 람다로 변경해 보겠습니다. power() 함수와 under_3() 함수를 람다로 변환하면 다음과 같은 코드가 됩니다. def 키워드로 선언했던 함수를 lambda로 바꾸고, return 키워드를 따로 쓰지않았다는 정도의 차이가 생겼습니다.

다음은 이전의 코드를 람다 lambda 구문을 사용한 프로그램의 예시코드입니다.

lambda01.py
```python
# 함수를 선언합니다.
power = lambda x:x*x
under_3 = lambda x:x<3

# 변수를 선언합니다.
list_input_a = [1, 2, 3, 4, 5]

# map() 함수를 사용합니다.
output_a = map(power, list_input_a)
print("# map() 함수의 실행 결과")
print("map(power, list_input_a):", output_a)
print("map(power, list_input_a):", list(output_a))
print()

# filter() 함수를 사용합니다.
output_b = filter(under_3, list_input_a)
print("# filter() 함수의 실행결과")
print("filter(under_3, list_input_a):", output_b)
print("filter(under_3, list_input_a):", list(output_b))
```
람다는 간단한 함수를 쉽게 선언하는 방법이라고 했는데, 왜 사용하는지가 의심스러울 정도로 복잡합니다. 람다는 다음과 같이 함수의 매개변수에 곧바로 넣을 수 있습니다. 코드가 굉장히 깔끔해집니다.

lambda02.py
```python
# 변수를 선언합니다.
list_input_a = [1, 2, 3, 4, 5]

# map() 함수를 사용합니다.
output_a = map(lambda x:x*x, list_input_a)
print("# map() 함수의 실행 결과")
print("map(power, list_input_a):", output_a)
print("map(power, list_input_a):", list(output_a))
print()

# filter() 함수를 사용합니다.
output_b = filter(lambda x:x<3, list_input_a)
print("# filter() 함수의 실행결과")
print("filter(under_3, list_input_a):", output_b)
print("filter(under_3, list_input_a):", list(output_b))
```
실행결과는 이전과 같습니다. 람다를 사용하면 코드를 더 깔끔하게 작성할 수 있고 함수가 매개변수로 넣어졌다고 확인하고 어떤 함수인지를 알기 위해 다시 찾아 올라가는 수고를 하지 않아도 됩니다. 지금은 매개변수가 하나인 람다만을 살펴보았는데, 다음과 같이 매개변수가 여러 개인 람다도 만들 수 있습니다.

lambda x,y : x*y

## 파일 처리

파일과 관련된 처리를 하는 함수는 표준 함수가 기본으로 제공됩니다. 파일은 크게 텍스트 파일과 바이너리 파일로 나뉘는데, 여기는 '텍스트 파일'과 관련된 내용만 살펴보겠습니다. 
파일을 처리하려면 일단 파일 열기 open 을 해야 합니다. 파일을 열면 파일 읽기 read 또는 파일 쓰기 write를 할 수 있습니다.

## 파일 열고 닫기

파일을 열 때는 open()함수를 사용합니다.

파일 객체 = open(문자열: 파일 경로, 문자열: 읽기 모드)

open() 함수의 첫 번째 매개변수에는 파일 경로 read를 입력하고, 두 번째 매개변수에는 모드 mode를 지정합니다 모드에는 다음과 같은 것을 지정할 수 있습니다.

w : write 모드(새로 쓰기 모드)
a : append 모드(뒤에 이어서 쓰기 모드)
r : read 모드(읽기 모드)

파일을 닫을 때는 close()함수를 사용합니다.

파일 객체.close()

다음은 파일을 열고 간단한 글을 써보는 예제코드입니다.

file_open.py
```python
# 파일을 엽니다.
file = open("basic.txt", "w")

# 파일에 텍스트를 씁니다.
file.write("Hello Python Programming...!")

# 파일을 닫습니다.
file.close()
```

## with 키워드

프로그램이 길어지면 open() 함수와 close() 함수 사이에 많은 코드가 들어갑니다. 조건문과 반복문이 들어가다 보면 파일을 열고 닫지 않는 실수를 하는 경우가 생길 수 있습니다. 이런 실수를 방지하기 위해 with 키워드라는 기능이 생겼습니다. with 키워드는 다음과 같은 형태의 구문으로 사용합니다.

with open(문자열: 파일 경로, 문자열: 모드) as 파일 객체:
    문장
    
이전 코드를 with 구문으로 수정하면 다음과 같습니다.
```python
with open("basic.txt", "w") as file:
    # 파일에 텍스트를 씁니다.
    file.write("Hello Python Programming ...!")
```

## 텍스트 읽기

파일에 텍스트를 쓸 때는 방금 살펴보았던 것처럼 write() 함수를 사용합니다. 반대로 파일을 읽을 때는 read() 함수를 사용합니다.

파일 객체.read()

파일을 열고 파일 객체의 read() 함수를 호출하기만 하면 내부에 있는 데이터를 모두 읽어 출력합니다.

다음은 read()함수로 텍스트를 읽는 예시 코드입니다.

file_read.py
```python
# 파일을 엽니다.
with open("basic.txt", "r") as file:
    # 파일을 읽고 출력합니다.
    contents = file.read()
print(contents)
```
## 텍스트 한 줄씩 읽기

텍스트를 사용해 데이터를 구조적으로 표현할 수 있는 방법으로 CSV, XML, JSON 등이 있습니다. 이 중에서 CSV를 살펴보겠습니다. CSV 는 Comma Seperated Values의 줄임말로 쉼표로 구분된 값들을 의미합니다. 

이름, 키, 몸무게
윤인성, 176, 62
연하진, 169, 50

CSV 파일은 한 줄에 하나의 데이터를 나타내며, 각각의 줄은 쉼표를 사용해 데이터를 구분합니다. 
이때 첫 번째 줄에 헤더 header를 넣어 각 데이터가 무엇을 나타내는지 설명해 줄 수 있습니다.

간단한 코드로 1000명의 이름, 키, 몸무게 데이터를 만드는 프로그램의 예시코드입니다.

file_write.py
```python
# 랜덤한 숫자를 만들기 위해 가져옵니다.
import random
# 간단한 한글 리스트를 만듭니다.
hanguls = list("가나다라마바사아자차카타파하")
# 파일을 쓰기 모드로 엽니다.
with open("info.txt", "w") as file:
    for i in range(1000):
        # 랜덤한 값으로 변수를 생성합니다.
        name = random.choice(hanguls) + random.choice(hanguls)
        weight = random.randrange(40, 100)
        height = random.randrange(140, 200)
        # 텍스트를 씁니다.
        file.write("{}, {}, {}\n".format(name, weight, height))
```
데이터가 많이 있다고 가정하고 한 줄씩 읽어 들일 때는 for 반복문을 다음과 같은 형태로 사용합니다.

for 한 줄을 나타내는 문자열 in 파일 객체:
    처리
    
이전에 만든 데이터를 한 줄씩 읽으면서 키와 몸무게로 BMI(비만도)를 계산해보는 프로그램의 예시코드입니다.

file_readlines.py
```python
# 결과를 계산합니다.
        bmi = int(weight) / ((int(height) / 100) ** 2)
        result = ""
        if 25 <= bmi:
            result = "과체중"
        elif 18.5 <= bmi:
            result = "정상 체중"
        else:
            result = "저체중"

        # 출력합니다.
        print('\n'.join([
            "이름: {}",
            "몸무게: {}",
            "키: {}",
            "BMI: {}",
            "결과: {}"
        ]).format(name, weight, height, bmi, result))
        print()
 ```
 
 ## 제너레이터
 
 제너레이터 generator는 파이썬의 특수한 문법 구조입니다. 제너레이터는 이터레이터를 직접 만들 때 사용하는 코드입니다. 함수 내부에 yield 키워드를 사용하면 해당 함수는 제너레이터 함수가 되며, 일반 함수와는 달리 함수를 호출해도 함수 내부의 코드가 실행되지 않습니다. 다음은 제너레이터 함수를 이용하는 프로그램의 예시코드입니다.
 
generator.py
```python
# 함수를 선언합니다.
def test():
    print("함수가 호출되었습니다.")
    yield "test"


# 함수를 호출합니다.
print("A 지점 통과")
test()

print("B 지점 통과")
test()
```

원래 test() 함수를 호출하면 "함수가 호출되었습니다"라는 문자열이 출력되어야 하지만, 출력되지 않습니다. 제너레이터 함수는 제너레이터를 리턴합니다. 제너레이터 객체는 next()함수를 사용해 함수 내부의 코드를 실행합니다. 이때 yield 키워드 부분까지만 실행하며, next()함수의 리턴값으로 yield 키워드 뒤에 입력한 값이 출력됩니다.

다음은 제너레이터 객체와 next()함수를 사용한 프로그램의 예시코드입니다.

generator01.py
```python
# 함수를 선언합니다.
def test():
    print("A 지점 통과")
    yield 1
    print("B 지점 통과")
    yield 2
    print("C 지점 통과")


# 함수를 호출합니다.
output = test()
# next() 함수를 호출합니다.
print("D 지점 통과")
a = next(output)
print(a)
print("E 지점 통과")
b = next(output)
print("F 지점 통과")
c = next(output)
print(c)
# 한 번 더 실행하기
next(output)
```

코드를 실행하면 next() 함수를 호출할 때마다 "A 지점 통과", "B 지점 통과", "C 지점 통과"처럼 함수 내부의 내용이 진행되는 모습을 확인할 수 있습니다. next() 함수 호출한 이후 yield 키워드를 만나지 못하고 함수가 끝나면 StopIteration 이라는 예외가 발생합니다.
이처럼 제너레이터 객체는 함수의 코드를 조금씩 실행할 때 사용합니다. 이는 메모리의 효율성을 위해서입니다. 제너레이터 객체와 이터레이터 객체는 완전히 같지는 않지만, 기본적인 단계에서는 거의 비슷하다고 봐도 무방합니다.

# 예외 처리

## 오류의 종류

프로그래밍 언어의 오류 error에는 크게 두 가지 종류가 있습니다.

1. 프로그램 실행 전에 발생하는 오류
2. 프로그램 실행 중에 발생하는 오류

두 가지 모두 '오류'라고 부릅니다. 실행 전에 발생하는 오류를 구문 오류 Syntax error라고 부르며, 프로그램 실행 중에 발생하는 오류를 예외 exception 또는 런타임 오류 runtime error 라고 구분합니다. 

## 구문 오류

구문 오류는 괄호의 개수, 들여쓰기 문제 등으로 인해 프로그램이 실행되기도 전에 발생하는 오류입니다. print()함수의 매개 변수에 넣은 문자열이 닫히지 않았습니다.

구문 오류가 발생하는 코드
```python
# 프로그램시작
print(" 프로그램이 시작되었습니다!")

# 구문 오류 발생 코드
print("# 예외를 강제로 발생시켜 볼게요!)
```
코드를 실행하면 EOL End Of Line에 문제가 있다고 합니다. 중요한 것은 앞에 적혀 있는 SyntaxError 라는 단어입니다. SyntaxError는 구문에 문제가 있어 프로그램이 실행조차 되지 않는 오류입니다. 구문오류는 해결하지 않으면 프로그램 자체가 실행되지 않습니다. 따라서 코드를 제대로 수정해야 합니다.

## 예외

예외 또는 런타임 오류는 실행 중에 발생하는 오류를 의미합니다.
 
예외가 발생하는 코드
```python
# 프로그램 시작
print("# 프로그램이 시작되었습니다!")

# 예외 발생 코드
list_a[1]
```
코드를 실행하면 일단 "# 프로그램이 시작되었습니다!"라는 문자열이 출력됩니다. 그러니까 일단 프로그램이 실행되었다는 의미입니다. 그런데 list_a[1]을 읽을 때 NameError가 발생했습니다.
이처럼 프로그램이 일단 실행된 다음, 실행 중에 발생하는 오류를 예외 exception 또는 런타임 오류 runtime error라고 부릅니다.

예외를 해결하는 방법도 구문 오류와 다르지 않습니다. 코드를 제대로 작성하면 됩니다. name 'list_a' is not defined는 list_a 라는 이름을 가진 것이 정의되지 않았다는 의미이므로, list_a라는 이름을 가진것을 만들어주면 됩니다.

## 기본 예외 처리

예외를 해결하는 모든 것을 예외 처리 exception handling라고 부릅니다. 예외를 처리하는 방법은 다음 두 가지로 나뉩니다.

1. 조건문을 사용하는 방법
2. try 구문을 사용하는 방법

일단 조건문을 사용해서 예외를 처리하는 방법부터 살펴보겠습니다. 이와 같은 예외 처리 방법을 기본 예외 처리라고 부릅니다.

## 예외 상황 확인하기

일단 예외가 발생할 상황을 만들어 보겠습니다.
```python
# 숫자를 입력받습니다.
number_input_a = int(input("정수 입력> "))

# 출력합니다.
print("원의 반지름:", number_input_a)
print("원의 둘레:", 2*3.14*number_input_a)
print("원의 넓이:", 3.14*number_input_a*number_input_a)
```
이 프로그램에 만약 정수를 입력하지 않으면 예외가 발생할 것입니다.

## 조건문으로 예외 처리하기

이전 코드에서 정수를 입력하지 않으면 문제가 발생합니다. 따라서 '정수를 입력하지 않았을 때'를 조건으로 구분해서 해당 상황일 때 다른 처리를 하도록 설정해 보겠습니다.
문자열의 isdigit() 함수를 사용해서 숫자로만 구성된 글자인지 확인합니다. 이렇게 하면 int()함수를 이용해 숫자로 변환할 수 없는 문자열을 반환하면서 발생하는 예외를 피할 수 있습니다.

다음은 조건문으로 예외를 처리하는 프로그램의 예시코드입니다.

handle_with_condition.py
```python
# 숫자를 입력받습니다.
user_input_a = input("정수 입력> ")

# 사용자 입력이 숫자로만 구성되어 있을 때
if user_input_a.isdigit():
    # 숫자로 반환합니다.
    number_input_a = int(user_input_a)
    # 출력합니다.
    print("원의 반지름:", number_input_a)
    print("원의 둘레:", 2*3.14*number_input_a)
    print("원의 넓이:", 3.14*number_input_a*number_input_a)
else:
    print("정수를 입력하지 않았습니다.")
```
코들를 실행하고 정수를 입력하면 정상적인 값을 출력합니다. 정수로 변환할 수 없는 문자열을 입력했을 때는 isdigit() 함수를 사용해 숫자로 구성되어 있지 않다는 것을 확인하고, else 구문 쪽으로 들어가서 "정수를 입력하지 않았습니다" 라는 문자열을 출력합니다. 프로그램이 중간에 강제로 죽지 않고 정상으로 종료됩니다. 프로그램을 작성할 때는 항상 예외적인 상황까지 모두 생가하는 습관을 기르는 게 좋습니다. 그러한 상황이 언제 발생하는지와 관련된 조건을 스스로 구분할 수 있으면 쉽게 예외를 처리할 수 있습니다.

## try except 구문

원래 초기의 프로그래밍 언어는 조건문으로만 예외를 처리했습니다. 하지만 예외가 발생할 상황을 예측하고 모두 조건문으로 처리하는 것은 매우 힘든 일입니다. 프로그래밍 언어의 구조적인 문제로 인해 조건문만으로 예외를 처리할 수 없는 경우도 있습니다.
그래서 요즘 프로그래밍 언어는 예외를 처리할 수 있는 구문을 제공합니다. 바로 try except 구문입니다. try except 구문의 기본적인 구조는 다음과 같습니다.

try:
    예외가 발생할 가능성이 있는 코드
except:
    예외가 발생했을 때 실행할 코드

그럼 이전의 예제를 try except 구문으로 변경해 보겠습니다. 예외가 발생할 가능성이 있는 코드를 모두 try 구문 안에 넣고 예외가 발생했을 때 실행할 코드를 모두 except 구문 안에 넣으면 됩니다. 어떤 상황에 예외가 발생하는지 완벽하게 이해하고 있지 않아도 프로그램이 강제로 죽어 버리는 상황을 막을 수 있습니다.

handle_with_try.py
```python
# try except 구문으로 예외를 처리합니다.
try:
    # 숫자로 변환합니다.
    number_input_a = int(input("정수 입력> "))
    # 출력합니다.
    print("원의 반지름:", number_input_a)
    print("원의 둘레:", 2*3.14*number_input_a)
    print("원의 넓이:", 3.14*number_input_a*number_input_a)
except:
    print("무언가 잘못되었습니다.")
```
코드를 실행하고 정수로 변환할 수 없는 문자열을 입력해도 프로그램이 강제로 종료되는 일 없이 예외 처리를 하고 정상적으로 종료됩니다.

## try except 구문과 pass 키워드 조합하기

프로그래밍을 하다 보면 이유는 정확히 모르겠지만, 어떤 부분에서 예외가 발생하는지 정도는 파악할 수 있는 상황이 있습니다. 예외가 발생하면 일단 처리해야 하지만, 해당 코드가 딱히 중요한 부분이 아니라면 일단 프로그램이 강제 종료되는 것부터 막자는 목적으로 except 구문에 아무 것도 넣지 않고 try 구문을 사용하게 됩니다.
하지만 구문 내부에 아무 것도 넣지 않으면 구문 오류가 발생하므로 pass 키워드를 넣어 줍니다.

try:
    예외가 발생할 가능성이 있는 코드
except:
    pass
    
예외를 잘 활용하면 간단한 코드로 필요한 기능을 구현할 수 있습니다.

다음은 숫자로 변환되는 것들만 리스트에 넣는 프로그램의 예시 코드입니다.

try_pass.py
```python
# 변수를 선언합니다.
from re import T


list_input_a = ["52", "273", "32", "스파이", "103"]

# 반복을 적용합니다.
list_number = []
for item in list_input_a:
    # 숫자로 변환해서 리스트에 추가합니다.
    try:
        float(item)  # 예외가 발생하면 알아서 다음으로 진행이 되지 않습니다.
        list_number.append(item)  # 예외 없이 통과했다면 리스트에 넣습니다.
    except:
        pass

# 출력합니다.
print("{} 내부에 있는 숫자는".format(list_input_a))
print("{}입니다.".format(list_number))
```
숫자로 변환할 수 없는 문자열이라면 float(item)를 실행할 때 예외가 발생합니다. 따라서 이를 이용해서 try except 구문으로 감싸고 예외가 발생하지 않는 경우에만 list_number.append(item)가 실행되도록 만드는 코드입니다.
물론 try except 구문은 if 구문을 활용하는 코드에 비해 아주 약간 느립니다. 파이썬 자체가 그렇게 속도를 중요시하는 프로그래밍 언어가 아니므로 코드를 조금 더 쉽게 작성할 목적이라면 사용해도 괜찮다고 생각합니다.

## try except else 구문

try except 구문 뒤에는 else 구문을 붙여서 사용하는 '예외가 발생하지 않았을 때 실행할 코드'를 정할 수 있습니다.

try:
    예외가 발생할 가능성이 있는 코드
except:
    예외가 발생했을 때 실행할 코드
else:
    예외가 발생하지 않았을 때 실행할 코드

try except else 구문을 사용할 때는 예외가 발생할 가능성이 있는 코드만 try 구문 내부에 넣고 나머지를 모두 else 구문으로 빼는 경우가 많습니다. 

다음은 try except else 구문을 사용한 프로그램의 예시코드입니다.
try_except_else.py
```python
# try except else 구문으로 예외를 처리합니다.
try:
    # 숫자로 변환합니다.
    number_input_a = int(input("정수 입력> "))
except:
    print("정수를 입력하지 않았습니다.")
else:
    # 출력합니다.
    print("원의 반지름:", number_input_a)
    print("원의 둘레:", 2*3.14*number_input_a)
    print("원의 넓이:", 3.14*number_input_a*number_input_a)
```
사실 코드를 보고 왜 이렇게 써야 하는지, 그냥 이전 코드처럼 try 구문 안에 모두 넣으면 안되는 건지 궁금할 수 있습니다. C++, C#, Java, JavaScript, PHP, ObjectiveC, Swift, Kotlin 등의 프로그래밍 언어는 예외 처리에 else 구문이 없습니다. 예외 처리에 else 구문이 있는 프로그래밍 언어는 파이썬과 루비 정도입니다.
수많은 프로그래밍 언어 중에 몇몇 프로그래밍 언어만 가지고 있는 기능은 다른 말로 하면, 그 기능이 없어도 프로그램을 만드는 데 문제가 없다는 것입니다. 한마디로 말해 꼭 이렇게 코드를 작성할 필요는 없고 else 구문을 사용하지 않고 try 구문 내부에 모두 넣고 처리해도 괜찮습니다. 편한 대로 사용하는 게 좋습니다.

## finally 구문

finally 구문은 예외 처리 구문에서 가장 마지막에 사용할 수 있는 구문입니다. 예외가 발생하든 발생하지 않든 무조건 실행할 때 사용하는 코드입니다.

try: 
    예외가 발생할 가능성이 있는 코드
except:
    예외가 발생했을 때 실행할 코드
else:
    예외가 발생하지 않았을 때 실행할 코드
finally:
    무조건 실행할 코드
    
다음은 구문을 모두 사용한 프로그램의 예제코드입니다.

try_except_else_finally.py
```python
# try except 구문으로 예외를 처리합니다.
try:
    # 숫자로 변환합니다.
    number_input_a = int(input("정수 입력> "))
    # 출력합니다.
    print("원의 반지름:", number_input_a)
    print("원의 둘레:", 2*3.14*number_input_a)
    print("원의 넓이:", 3.14*number_input_a*number_input_a)
except:
    print("정수를 입력해달라고 했습니다!")
else:
    print("예외가 발생하지 않았습니다.")
finally:
    print("일단 프로그램이 어떻게든 끝났습니다.")
```

## try, except, finally 구문의 조합

예외 처리 구문은 다음과 같은 규칙을 지켜야 합니다.

1. try 구문은 단독으로 사용할 수 없으며, 반드시 except 구문 또는 finally 구문과 함께 사용해야 합니다.
2. else 구문은 반드시 except 구문 뒤에 사용해야 합니다.

이를 조합해 보면 다음과 같습니다.

1. try + except 구문 조합
2. try + except + else 구문 조합
3. try + except + finally 구문 조합
4. try + except + else + finally 구문 조합
5. try + finally 구문 조합

이 외의 조합은 실행했을 때 구문 오류가 발생합니다. 
 
## finally에 대한 오해
 
일반적으로 finally 키워드를 설명하는 예제로 '파일 처리'를 많이 사용합니다.
파일을 열고 있으면 해당 파일을 이동하거나 덮어 씌우거나 하는 일이 불가능해집니다. 따라서 프로그램에서 파일을 열었으면open 무조건 닫아야close 합니다. 파일을 제대로 닫았는지는 파일 객체의 clsoed 속성으로 알 수 있습니다.

다음은 파일이 제대로 닫혔는지 확인하는 프로그램의 예시코드입니다.

file_closed01.py
```python
# try except 구문을 사용합니다.
try:
    # 파일을 엽니다.
    file = open("info.txt", "w")
    # 여러가지 처리를 수행합니다.
    # 파일을 닫습니다.
    file.close()
except Exception as e:
    print(e)

print("# 파일이 제대로 닫혔는지 확인하기")
print("file.closed:", file.closed)
```

물론 현재 예제처럼 간단하게 실행되고 끝나는 프로그램이라면 큰 상관은 없습ㄴ디ㅏ. 프로그램이 끝날 때 자신이 열었던 파일을 자동으로 모두 닫습니다. 하지만 이 프로그램이 항상 켜져 있는 프로그램이라면 문제가 생길 수 있습니다. *항상 켜져있는 프로그램을 데몬(daemon) 또는 서비스(service)라고 부릅니다. 예를 들어 컴퓨터의 성능을 감시하는 프로그램, 파일의 변경을 감시하는 프로그램, 사용자에게 웹 페이지를 제공해 주는 웹 서버 등이 모두 데몬이자 서비스입니다.

파일을 닫을 때는 close() 함수를 사용합니다. 그런데 중간 과정에서 예외가 발생해서 try 구문 중간에 튕겨 버리면 파일이 제대로 닫히지 않는 문제가 발생할 수 있습니다.

다음은 파일 처리 중간에 예외를 발생시키는 프로그램의 예제코드입니다.
file_closed02.py
```python
# try except 구문을 사용합니다.
try:
    # 파일을 엽니다.
    file = open("info.txt", "w")
    # 여러 가지 처리를 수행합니다.
    예외.발생해라()
    # 파일을 닫습니다.
    file.close()
except Exception as e:
    print(e)

print("# 파일이 제대로 닫혔는지 확인하기")
print("file.closed:", file.closed)
```
코드를 실행해보면 closed가 False이므로 파일이 닫히지 않았다는 것을 알 수 있습니다. 따라서 반드시 finally 구문을 사용하여 파일을 닫게 해야합니다.

다음은 finally 구문을 사용해서 파일을 닫는 프로그램의 예시코드입니다.
file_closed03.py
```python
# try except 구문을 사용합니다.
try:
    # 파일을 엽니다.
    file = open("info.txt", "w")
    # 여러 가지 처리를 수행합니다.
    예외.발생하라()
except Exception as e:
    print(e)
finally:
    # 파일을 닫습니다.
    file.close()

print("# 파일이 제대로 닫혔는지 확인하기")
print("file.closed:", file.closed)
```
이는 finally 키워드와 관련된 기본적인 설명이며, 모든 프로그래밍 언어에서 예외 처리를 설명할 때 단골로 나오는 이야기입니다. 그런데 다음과 같이 코드를 사용할 수 있을 까라는 생각을 할 수 도 있습니다.

다음은 try except 구문 끝난 후 파일을 닫는 프로그램의 예제 코드입니다.
file_closed04.py
```python
# try except 구문을 사용합니다.
try:
    # 파일을 엽니다.
    file = open("info.txt", "w")
    # 여러 가지 처리를 수행합니다.
    예외.발생하라()
except Exception as e:
    print(e)

# 파일을 닫습니다.
file.close()
print("# 파일이 제대로 닫혔는지 확인하기")
print("file.closed:", file.closed)
```
그냥 try except 구문이 모두 끝난 후에 파일을 닫으면 아무 문제 없습니다.
한마디로 파일 처리를 할 때 무조건 finally 키워드를 사용해야 한다는 것은 말도 안되는 이야기입니다. finally 키워드는 어떤 조건에 무조건 사용해야 하는 게 아니라 finally 키워드를 사용하면 코드가 깔끔해질 것 같다고 생각되는 경우에 사용합니다.

## try 구문 내부에서 return 키워드를 사용하는 경우

finally 구문은 반복문 또는 함수 내부에 있을 때 위력을 발휘합니다. 다음은 try 구문 내부에서 return 키워드를 사용하는 프로그램의 예시코드입니다.

try_return01.py
```python
# test() 함수를 선언합니다.
def test():
    print("test() 함수의 첫 줄입니다.")
    try:
        print("try 구문이 실행되었습니다.")
        return
        print("try 구문의 return 키워드 뒤입니다.")
    except:
        print("except 구문이 실행되었습니다.")
    else:
        print("else 구문이 실행되었습니다.")
    finally:
        print("finally 구문이 실행되었습니다.")
    print("test() 함수의 마지막 줄입니다.")


# test() 함수를 호출합니다.
test()
```
try 구문 내부에 return 키워드가 있다는 것이 포인트입니다. try 구문 중간에서 탈출해도 finally 구문은 무조건 실행됩니다. 따라서 함수 내부에서 파일 처리 코드를 깔끔하게 만들고 싶을 때 finally 구문을 활용하는 경우가 많습니다. try 구문에서 원할 때 return 키워드로 빠져나가도 파일이 무조건 닫히기 때문입니다.

다음은 finally 키워드를 활용하는 프로그램의 예시코드입니다.

try_return02.py
```python
# 함수를 선언합니다.
def write_text_file(filename, text):
    # try except 구문을 사용합니다.
    try:
        # 파일을 엽니다.
        file = open(filename, "w")
        # 여러 가지 처리를 수행합니다.
        return
        # 파일에 텍스트를 입력합니다.
        file.write(text)
    except Exception as e:
        print(e)
    finally:
        # 파일을 닫습니다.
        file.close()


# 함수를 호출합니다.
write_text_file("test.txt", "안녕하세요!")
```
만약 중간에 return 키워드 등으로 함수를 빠져나갈 때마다 close()를 하도록 코드를 작성했다면 코드가 굉장히 복잡해질 것입니다. 하지만 이렇게 finally 구문에서 close()함수를 호출하도록 코드를 작성하면 코드가 깔끔해집니다.

## 반복문과 함께 사용하는 경우

finally 구문은 무조건 실행됩니다. 따라서 반복문으로 break로 빠져나갈 때도 마찬가지입니다. 
다음은 반복문과 finally 구문을 함께 사용하는 프로그램의 예시코드입니다.

finally_loop.py
```python
print("프로그램이 시작되었습니다.")

while True:
    try:
        print("try 구문이 실행되었습니다.")
        break
        print("try 구문의 break 키워드 뒤입니다.")
    except:
        print("except 구문이 실행되었습니다.")
    finally:
        print("finally 구문이 실행되었습니다.")
    print("while 반복문의 마지막 줄입니다.")
print("프로그램이 종료되었습니다.")
```
코드를 실행하면 break 키워드로 try 구문 전체를 빠져나가도 finally 구문이 실행되는 것을 볼 수 있습니다.

## 예외 고급

현실에서 어떤 사건이 발생하면 "누가, 언제, 어디서"라는 정보가 생깁니다. 프로그래밍 언어도 예외가 발생하면 예외와 관련된 정보가 생깁니다. 그리고 이러한 예외 정보는 예외 객체 exception object에 저장됩니다. 예외 객체는 다음과 같은 형태로 사용합니다.

try:
    예외가 발생할 가능성이 있는 구문
except 예외의 종류 as 예외 객체를 활용할 변수 이름:
    예외가 발생했을 때 실행할 구문
    
## 예외 객체

처음 예외 객체를 사용해 보면 '예외의 종류'가 뭔지 몰라 당황하는 경우가 많습니다. 그럴 때는 '모든 예외의 어머니'라고 불리는 Exception을 사용합니다.
*Exception 은 '클래스'입니다. 

이를 활용해 예외 객체의 자료형과 예외 객체 자체를 출력해 보는 프로그램의 예시코드입니다.
except01.py
```python
# try except 구문으로 예외를 처리합니다.
try:
    # 숫자를 반환합니다.
    number_input_a = int(input("정수 입력> "))
    # 출력합니다.
    print("원의 반지름:", number_input_a)
    print("원의 둘레:", 2*3.14*number_input_a)
    print("원의 넓이:", 3.14*number_input_a*number_input_a)
except Exception as exception:
    # 예외 객체를 출력해봅니다.
    print("type(exception):", type(exception))
    print("exception:", exception)
```
코드를 실행하고 문자를 입력하여 예외를 강제로 발생시켜 보면 예외객체의 자료형과 내용이 출력되는 것을 알 수 있습니다. 만약 큰 규모의 웹 서비스를 구축한다면 내부에서 다양한 예외가 발생합니다. 예외가 발생할 때 이러한 정보를 메일 등으로 보내도록 해서 수집하면 이후에 프로그램을 개선하는 데 큰 도움이 됩니다.

## 예외 구분하기

예외 객체를 사용하면 except 구문을 if 조건문처럼 사용해서 예외를 구분할 수 있습니다.

## 여러가지 예외가 발생할 수 있는 상황

다음은 여러가지 예외가 발생할 수 있는 예시코드입니다.
except02.py
```python
# try except 구문으로 예외를 처리합니다.
try:
    # 숫자를 반환합니다.
    number_input_a = int(input("정수 입력> "))
    # 출력합니다.
    print("원의 반지름:", number_input_a)
    print("원의 둘레:", 2*3.14*number_input_a)
    print("원의 넓이:", 3.14*number_input_a*number_input_a)
except Exception as exception:
    # 예외 객체를 출력해봅니다.
    print("type(exception):", type(exception))
    print("exception:", exception)
```

## 예외 구분하기

파이썬은 except 구문 뒤에 예외의 종류를 입력해서 예외를 구분할 수 있습니다.

try:
    예외가 발생할 가능성이 있는 구문
except 예외의 종류A:
    예외가 발생했을 때 실행할 구문
except 예외의 종류B:
    예외가 발생했을 때 실행할 구문
except 예외의 종류C:
    예외가 발생했을 때 실행할 구문
 
다음은 ValueError와 IndexError를 구분하는 프로그램의 예시코드입니다.

except_multi.py
```python
# 변수를 선언합니다.
list_number = [52, 273, 32, 72, 100]

# try excpet 구문으로 예외를 처리합니다.
try:
    # 숫자를 입력받습니다.
    number_input = int(input("정수 입력> "))
    # 리스트의 요소를 출력합니다.
    print("{}번 째 요소: {}".format(number_input, list_number[number_input]))
except ValueError:
    # ValueError가 발생하는 경우
    print("정수를 입력해 주세요!")
except IndexError:
    # IndexError가 발생하는 경우
    print("리스트의 인덱스를 벗어났습니다!")
```

## 예외 구분 구문과 예외 객체

예외를 구분할 때 각각의 except 구문 뒤에 예외 객체를 붙여 활용할 수도 있습니다. 마찬가지로 as 키워드를 사용하면 됩니다. 예외 구문과 예외 객체를 실습하는 프로그램의 예시코드입니다.

except_as.py
```python
# 변수를 선언합니다.
list_number = [52, 273, 32, 72, 100]

# try except 구문으로 예외를 처리합니다.
try:
    # 숫자를 입력받습니다.
    number_input = int(input("정수 입력> "))
    # 리스트의 요소를 출력합니다.
    print("{}번 째 요소: {}".format(number_input, list_number[number_input]))
except ValueError as exception:
    # ValueError가 발생하는 경우
    print("정수를 입력해 주세요")
    print("exception:", exception)
except IndexError as exception:
    print("리스트의 범위를 벗어났습니다!")
    print("exception:", exception)
```

## 모든 예외 잡기

except 구문으로 예외를 구분하면 if, elif, else 조건문처럼 차례대로 오류를 검출하면서 확인합니다. 만약 예외 조건에 일치하는 것이 없다면 당연히 예외가 발생하며 프로그램이 강제 종료됩니다.
예를 들어 중간에 예외.발생해주세요() 를 사용하는데 예외라는 이름의 변수가 없으므로 예외가 발생합니다. 이름이 없으므로 NameError가 발생할 텐데, 예외 처리 구분 중에 NameError가 없습니다.

예외 처리를 했지만 예외를 못 잡는 경우의 프로그램의 예시코드입니다.
except03.py
```python
# 변수를 선언합니다.
list_number = [52, 273, 32, 72, 100]

# try except구문으로 예외를 처리합니다.
try:
    # 숫자를 입력받습니다.
    number_input = int(input("정수 입력>"))
    # 리스트의 요소를 출력합니다.
    print("{}번 째 요소: {}".format(number_input, list_number[number_input]))
    예외.발생해주세요()
except ValueError as exception:
    # ValueError가 발생하는 경우
    print("정수를 입력해 주세요")
    print("exception:", exception)
except IndexError as exception:
    print("리스트의 범위를 벗어났습니다!")
    print("exception:", exception)
``` 
이렇게 되면 예외가 발생해 프로그램이 강제 종료됩니다. 그래서 else 구문처럼 마지막에는 모든 예외의 부모라고 할 수 있는 Exception을 넣어 프로그램이 죽지 않게 하는 것이 좋습니다.
다음은 모든 예외를 잡는 프로그램의 예시코드입니다.

except_all.py
```python
# 변수를 선언합니다.
list_number = [52, 273, 32, 72, 100]

# try except 구문으로 예외를 처리합니다.
try:
    # 숫자를 입력받습니다.
    number_input = int(input("정수 입력> "))
    # 리스트의 요소를 출력합니다.
    print("{}번 째 요소: {}".format(number_input, list_number[number_input]))
    예외.발생해주세요()
except ValueError as exception:
    # ValueError가 발생하는 경우
    print("정수를 입력해 주세요")
    print("exception:", exception)
except IndexError as exception:
    print("리스트의 범위를 벗어났습니다!")
    print("exception:", exception)
except Exception as exception:
    # 이외의 예외가 발생한 경우
    print("미리 파악하지 못한 예외가 발생했습니다.")
    print(type(exception), exception)
```
코드를 실행하면 프로그램이 중간에 강제 종료되지 않으며 앞의 결과와 같이 출력합니다. 참고로 너무 치명적인 문제인데도 프로그램이 종료되지 않게 만들면 그건 또 그것대로 문제가 될 수 있으므로 상황을 꼭 확인하는 것이 좋습니다.

지금까지 예외를 처리하는 방법에 대해서 알아보았습니다.예외 처리에서 가장 중요한 것은 '이 코드에서 어떤 예외가 발생할 것인가'를 잘 예측하는 것입니다.

수많은 게임을 만들어 본 개발자들도 게임 내부에서 예외를 제대로 잡지 못해서 'Microsoft Visual C++ Runtime Library - Runtime Error!' 등의 메시지가 뜨면서 프로그램이 강제 종료되는 경우가 허닿바니다. 또한 잘 만들어진 게임 서버도 사람이 몰렸다는 이유만으로 예외가 발생해서 서버가 터져버렸어요라는 공지를 띄우기도합니다. ktx를 예매할 때, 공연 티켓을 예매할 때도 사람들이 너무 몰려 데이터베이스 연결이 많아지면 예외가 발생해서 긴급 유지보수를 진행하는 경우도 있습니다. 너무 많은 상황을 모두 예측할 수는 없지만, 최대한 잡을 수 있는 것들을 예측해 보고 잡을 수 있도록 노력하는 것이 개발자의 자세라고 할 수 있습니다.

## raise 구문

프로그램이 강제 종료되는 것을 막기 위해 예외는 꼭 처리해야 합니다. 하지만 프로그램을 개발하는 동안에는 '아직 구현되지 않은 부분이니까 확실하게 문제가 생기게 만들자' 또는 '이 부분을 그냥 넘어가면 나중에 큰 문제가 발생하니까 여기에서 강제 종료시키자'라는 경우도 있습니다.

이전에 pass 키워드를 배우면서 다음과 같은 예가 있었습니다.

```python
# 입력을 받습니다.
number = input("정수 입력> ")
number = int(number)
# 조건문 사용
if number > 0:
    # 양수일 때: 아직 미구현 상태입니다.
    raise NotImplementedError
else: 
    # 음수일 때: 아직 미구현 상태입니다.
    raise NotImplementedError
```
아직 구현되지 않은 부분이므로 일부러 예외를 발생시켜 프로그램을 죽게 만들어 잊어버리지 않도록하는 것입니다. 이때 사용한 raise 키워드가 바로 예외를 강제로 밠애시키는 기능을 합니다.

raise 예외 객체

사용방법은 간단합니다. raise 뒤에 예외 이름을 입력해 주면 됩니다.
이때 출력되는 메시지를 원하는 형태로 만들고 싶다면 예외 클래스를 만들어야 합니다. 일반적으로 많이 사용되는 내용은 아닙니다.
